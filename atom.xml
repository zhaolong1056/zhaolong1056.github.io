<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夕阳西下，断肠人在天涯</title>
  
  <subtitle>好好学习，天天向上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-01T15:12:28.631Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhao long</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python正则表达式</title>
    <link href="http://yoursite.com/2019/10/01/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/01/Python正则表达式/</id>
    <published>2019-10-01T15:09:10.000Z</published>
    <updated>2019-10-01T15:12:28.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式-Regular-expression-operations"><a href="#正则表达式-Regular-expression-operations" class="headerlink" title="正则表达式  Regular expression operations"></a>正则表达式  Regular expression operations</h3><ul><li>Python通过re库提供对正则表达式的支持</li><li>一般步骤<ul><li>将正则表达式的字符串形式编译为Pattern实例</li><li>使用Pattern实例处理文本并获取匹配的结果Match实例</li><li>在match的基础上进行其他操作</li></ul></li><li>Both patterns and strings to be searched can be Unicode strings (str) as well as 8-bit strings (bytes).</li><li>字符串和模板的字符串必须是str或者bytes，不能混合使用</li></ul><h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><ul><li>编译：将程序翻译成二进制</li><li>预编译：提前将字符串模板成二进制</li><li>加快速度，编译好的模板数据可以多次使用</li><li>re.compile()  对象是 re.compile(‘(.<em>)——(.</em>)’)</li><li>已经编译的模板字符串可以当做<code>match</code>的参数</li><li>在处理大数据的时候比较有用 </li><li>复杂的表达式需要预编译</li><li>re.complile(“*”).match()  <strong>常用的方式之一</strong></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>匹配字符<ul><li><img src="/2019/10/01/Python正则表达式/dd61a65a.png" alt="字符匹配1"></li><li><img src="/2019/10/01/Python正则表达式/c3d6c1bf.png" alt="字符匹配2"></li><li><img src="/2019/10/01/Python正则表达式/fad52ec1.png" alt="字符匹配3"></li><li>\b：<strong>空格和其他非单词字符</strong> 作为边界 \bthe the前面有空格或其他非单词字符  the\b  the后面有空格或者其他非单词字符</li><li>\B 和上面的\b情况相反</li></ul></li><li>re.match(pattern, string, flags=0)  匹配从第一开始<ul><li><strong>从首字母完整匹配</strong></li><li><strong>且只匹配一次，后面的不再处理</strong></li><li>相当于 检查前缀字符串</li><li>If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object.</li><li>Return None if the string does not match the pattern; note that this is different from a zero-length match.</li><li>字符串从头匹配，必须是<strong>字符串的起始位置</strong><ul><li>有匹配的，返回匹配的对象<ul><li>re.Match 对象</li><li>包含位置和匹配对象 span match</li><li><strong>使用.group()返回实际字符</strong></li><li>或者直接在后面[0]，返回第一个匹配的数据</li></ul></li><li>没有匹配的，返回None</li><li><img src="/2019/10/01/Python正则表达式/b3133f1f.png" alt="match返回结构"></li><li>&lt;re.Match object; span=(0, 18), match=’chenyuqi is a gile’&gt;<ul><li>group()<strong>默认匹配字符串全部显示,省略了0</strong></li><li>group()参数0,1等<strong>表示模板字符串中()的顺序对应的字符串</strong></li></ul></li></ul></li></ul></li><li>re.search(pattern, string, flags=0) 搜索<ul><li><em>Scan through string*</em> looking for the first location where the regular expression pattern produces a match, </li><li>and return a corresponding match object. </li><li>Return None if no position in the string matches the pattern;</li><li>在<strong>字符串中搜索匹配模板的第一个位置，返回match对象</strong></li><li><strong>搜索包含就可以</strong></li><li>&lt;re.Match object; span=(3, 6), match=’xyz’&gt;11</li></ul></li><li>re.findall(pattern, string, flags=0) <ul><li>查找所有的元素</li><li>从左到右，返回所有匹配结果<strong>字符串</strong>的<strong>列表</strong></li><li>当匹配模式中包含多个组的时候，<strong>返回的是元素是元素的列表</strong></li><li>字符串中模式的所有非重叠匹配</li></ul></li><li>re.split(pattern, string, maxsplit=0, flags=0)  切割<ul><li>Split string by the occurrences of pattern. </li><li>按照字符串模式切割字符串</li><li>和字符串的split函数类似，但是<strong>更为随意</strong></li></ul></li><li>re.finditer(pattern, string, flags=0)   筛选<ul><li><strong>同find</strong>，但是返回一个<strong>迭代器</strong></li></ul></li><li>re.sub(pattern, repl, string, count=0, flags=0) <strong>替换</strong>，<strong>拦截关键字</strong><ul><li>使用repl替换根据pattern匹配到的字符串，返回新的字符串</li><li><strong>默认替换所有的</strong></li><li>re.subn(pattern, repl, string, count=0, flags=0) <ul><li>原理同sub</li><li>但是返回的是一个元素<code>(new_string, number_of_subs_made)</code> （新的字符串，替换次数）</li></ul></li></ul></li></ol><h4 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h4><ul><li>是正则表达式匹配的两种模式<ul><li>贪婪模式：匹配<strong>尽可能多</strong>的字符</li><li>非贪婪匹配模式：匹配<strong>尽可能少</strong>的字符<ul><li>使用<code>?</code></li></ul></li></ul></li><li>默认贪婪模式</li></ul><h5 id="常用的简单正则表达式"><a href="#常用的简单正则表达式" class="headerlink" title="常用的简单正则表达式"></a>常用的简单正则表达式</h5><ol><li><p>QQ号码</p><ul><li>^<a href="\d{4,10}">1-9</a>$</li></ul></li><li><p>Phone</p><ul><li>^1<a href="\d{9}">34578</a>$</li></ul></li><li><p>电话</p><ul><li>^0<a href="\d{1,2}">1-9</a>-<a href="\d{6-7}">1-9</a></li></ul></li><li><p>IP地址</p><ul><li>^(\d){1,3}.(\d){1,3}.(\d){1,3}.(\d){1,3}$  简单的，不准去</li><li>0-255  0-9 19-99 100-199 200-255  200-249 250-255<ul><li>^(\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5]), (\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5]),<br>(\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5]),(\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5])$</li></ul></li></ul></li><li><p>邮箱</p><ul><li>\w+</li><li>\w(.|_|\w)+</li><li>\w(.|_|\w)+@</li><li>\w(.|_|\w)+@(\w+.){1,3}\w+</li></ul></li><li><p>出生日期</p><ul><li>1985-05-22  01-12  01-31</li><li>(18\d{2}| 19\d{2} | 20[0-1]\d) 年份</li><li>(1[0-2] | 0[1-9])  月份</li><li>0[1-9] |[1-2][0-9]| 3[0-1] 日期</li></ul></li></ol><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正则表达式-Regular-expression-operations&quot;&gt;&lt;a href=&quot;#正则表达式-Regular-expression-operations&quot; class=&quot;headerlink&quot; title=&quot;正则表达式  Regular express
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python面对对象编程2</title>
    <link href="http://yoursite.com/2019/10/01/Python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B2/"/>
    <id>http://yoursite.com/2019/10/01/Python面对对象编程2/</id>
    <published>2019-10-01T15:07:37.000Z</published>
    <updated>2019-10-01T15:12:36.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(父类)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__(self)</span><br></pre></td></tr></table></figure><h4 id="构造函数式"><a href="#构造函数式" class="headerlink" title="构造函数式"></a>构造函数式</h4><ul><li><p>当父类和子类<strong>都有构造函数时</strong></p><ul><li>子类的构造函数必须引号分类的构造函数</li><li>传入参数<ul><li><strong>子类的构造函数参数列表必须包含父类构造函数的参数列表</strong></li><li><strong>super().<strong>init</strong>(参数列表) 父类的参数必须提供</strong><ul><li>注意，<strong>参数列表中没有self</strong></li></ul></li></ul></li><li><img src="/2019/10/01/Python面对对象编程2/1acfc24b.png" alt="子类的构造函数缺少父类的引用"></li></ul></li><li><p>调用父类的构造函数</p><ol><li>父类名称.<strong>init</strong>(self, 参数列表)<ul><li>必须有self</li><li>通过self指定是谁的上游，父类</li></ul></li><li>super().<strong>init</strong>(参数列表)<ul><li>不能有self</li><li>super() <ul><li><strong>super表示该类的父类</strong></li><li>super()表示<strong>父类对象</strong></li></ul></li></ul></li></ol></li><li><p>继承</p><ul><li><p>子类继承父类的属性和方法</p></li><li><p>子类拥有同名方法时，使用自己的方法</p></li><li><p>意义</p><ul><li>代码，数据 重用</li><li>子类会覆盖父类,当出现同名属性和方法时</li></ul></li><li><p>多继承</p><ul><li><img src="/2019/10/01/Python面对对象编程2/116680a1.png" alt="多继承属性或方法查找路径"></li><li><strong>引用父类的初始化构造函数，容易出现覆盖属性的现象</strong><ul><li>程序顺序执行</li></ul></li><li>只能使用第一种方法 类名.<strong>init</strong>(self)</li><li>类的<code>__mro__</code>属性表示类的查找方向</li><li>多继承：有多个父类<ul><li>不同命的方法和属性：</li><li>重名的方法和属性：按照<strong>mro</strong>的指示查找，<strong>只要找到，就不在继续找了</strong></li></ul></li><li>属性的继承<ul><li>没有<strong>init</strong>时，属性按照引用类的顺序使用</li><li>当有<strong>init</strong>时，属性会出现覆盖的情况，和父类的init初始化函数顺序有关</li><li><strong>和属性的命名空间有关</strong></li><li>属性是私有的</li></ul></li><li>方法<ul><li>只和类的顺序有关，谁在前，执行谁的方法      </li><li>方法是共有的</li></ul></li></ul></li><li><p><strong>私有属性不能继承</strong></p><ul><li>名称都变了，在外部使用不了</li></ul></li></ul></li><li><p>基类 object</p><ul><li>所有的类都是从object继承的 </li><li>但是 object <strong>省略</strong></li></ul></li><li><p>类的特有属性</p><ul><li><p>从object继承的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, </span><br><span class="line"><span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, </span><br><span class="line"><span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>,</span><br><span class="line"> <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>name 类的名称</li><li>doc  说明文档</li><li>module 类的位置</li><li>bases 类的父类</li><li>dict 类的所有属性和值，字典</li></ul></li></ul></li></ul><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><ul><li>解决父类的初始化</li><li>解决父类的多次重复初始化的问题<ul><li><strong>只初始化一次</strong></li><li>使用类名.<strong>init</strong>调用时，会<strong>多次初始化</strong></li><li><img src="/2019/10/01/Python面对对象编程2/28a4b5e9.png" alt="super"></li><li><img src="/2019/10/01/Python面对对象编程2/d416b7b3.png" alt="类名调用"></li><li>super(类,self) 表示<strong>类的所有父类</strong>，而不是一个<ul><li>不需要重复调用</li></ul></li><li>节约资源<h5 id="isinstance-object-classinfo"><a href="#isinstance-object-classinfo" class="headerlink" title="isinstance(object, classinfo)"></a>isinstance(object, classinfo)</h5></li></ul></li><li><strong>判断object是不是改类型的参数和子类</strong></li><li>classinfo <strong>可以是一个元祖</strong></li><li>type对类型是属于严格检查  &lt;class ‘<strong>main</strong>.C’&gt;</li><li>isinstance 对类的检查包括父类</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>解决<strong>可扩展性</strong></li><li>一个接口，多种形态<ul><li>通过把对象当做参数，调用自己的方法，而不是继承的方法</li></ul></li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li>@staticmethod</li><li><strong>只和类有关的，不需要实例化就可以使用的</strong></li><li>不能使用<strong>cls和self</strong></li><li><strong>和 类对象和实例对象无关的方法</strong></li><li>对象和类对象都可以调用</li><li>&lt;class ‘function’&gt; <strong>不和对象，类绑定</strong></li></ul><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><ul><li>把类当做参数 <code>cls</code></li><li>类.方法 在外部使用</li><li>@classmethod</li><li>内部：类方法 @classmethod  cls做参数</li><li>外部：把对象当做方法</li><li><strong>同名函数可以覆盖</strong>，类的最后使用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类的继承&quot;&gt;&lt;a href=&quot;#类的继承&quot; class=&quot;headerlink&quot; title=&quot;类的继承&quot;&gt;&lt;/a&gt;类的继承&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python面对对象编程1</title>
    <link href="http://yoursite.com/2019/10/01/Python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B1/"/>
    <id>http://yoursite.com/2019/10/01/Python面对对象编程1/</id>
    <published>2019-10-01T15:04:01.000Z</published>
    <updated>2019-10-01T15:12:52.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面对对象的编程思想"><a href="#面对对象的编程思想" class="headerlink" title="面对对象的编程思想"></a>面对对象的编程思想</h3><ul><li>函数是对代码块的抽象，代码重用</li><li>面向对象编程是对<strong>代码重用的更高的方式</strong></li><li>面向过程：根据<strong>业务逻辑从上到下</strong>写代码</li><li>函数式： 将某些功能代码封装到函数中，无需重复编写整个功能代码的实现，仅调用即可</li><li>面向对象：将函数进行封装，更快速的开发程序，减少重复代码的编写过程<ul><li>代码的重用</li><li>数据的重用n</li><li>数据的封装，独立性</li></ul></li></ul><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><ul><li>类：蓝图，模型</li><li>对象： 根据类实例处理的，实际对应的</li></ul><h5 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h5><ul><li>class 关键字</li><li>类型 &lt;calss “type”&gt;  数据类型</li><li>可以初始化多个对象 </li><li>对对象的属性和方法进行了封装<ul><li>数据的重用 属性  </li><li>代码的重用 方法</li></ul></li></ul><ol><li><p>一般语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称<span class="params">()</span>:</span></span><br><span class="line">   代码块</span><br><span class="line">   属性： 变量   使用属性 self.变量</span><br><span class="line">   方法   函数   第一个参数 self</span><br></pre></td></tr></table></figure></li><li><p>类的方法</p><ul><li>类的方法是 bound method，绑定在self上</li><li>&lt;bound method People.say of &lt;<strong>main</strong>.People object at 0x000001FA8D05A188&gt;&gt;</li><li>所有的实例对象共用一个方法</li></ul></li><li><p>本质</p><ul><li>函数重用： 方法地址一样，共享的，绑定方法区分<strong>谁调用函数</strong>，<strong>方法共享</strong></li><li>数据： 属性地址不一样，属于每一个对象，<strong>属性对立</strong></li></ul></li><li><p>构造函数 <strong>init</strong>(self)</p><ul><li>对象创建时，自动运行的函数</li><li>传递参数，初始化对象</li><li>对应的是创建对象，实例化的<strong>参数列表</strong></li><li>一般对象的属性是放在构造函数中的</li><li><strong>类中默认包含构造函数</strong></li></ul></li><li><p>析构函数 <strong>del</strong>(self)</p><ul><li>对象删除时或者生命周期结束时，自动运行的函数</li></ul></li><li><p>动态绑定增加属性和方法</p><ul><li>迭代开发</li><li>在对象实例化之后，使用<code>对象.属性=数值</code>进行增加属性</li><li>属性独属于该对象，其他对象不能共享</li><li>同列 方法类似<ul><li>只能使用lambda</li><li>不能使用self</li></ul></li></ul></li><li><p>重载运算符</p><ul><li><strong>不同的类型对运算符有不同的解释</strong></li><li>针对<strong>本类型</strong>，对运算符进行新的解释</li><li><strong>不能出现对一个运算符的多种解释</strong></li></ul></li><li><p>有名对象和匿名对象</p><ul><li>c = People()  有名对象</li><li>People()   匿名对象</li></ul></li><li><p>类的复制</p><ul><li>类似对象复制</li><li>属于<strong>地址引用</strong></li></ul></li></ol><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><ul><li>类()</li><li>类的实例化</li><li>类型 &lt;class ‘<strong>main</strong>.star’&gt; 数据类型实例化</li></ul><h5 id="self"><a href="#self" class="headerlink" title="self"></a>self</h5><ul><li>self指向类实例化的对象，实例化以后的对象地址</li><li>self只能用在绑定的方法上，就是<strong>参数包含self的方法</strong></li><li>在类定义中，self可以调用属性和方法</li><li>属性和方法<strong>属于实例化的对象</strong></li><li>在类定义中使用属性必须是self.属性</li><li>方法的第一个参数必须是self<ul><li>在类定义中，使用定义的方法也必须是self.方法</li></ul></li><li>只应用于类定义的内部</li><li><img src="/2019/10/01/Python面对对象编程1/06c1a6cd.png" alt="类本质"></li><li><img src="/2019/10/01/Python面对对象编程1/03e6fcdc.png" alt="类本质"></li></ul><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul><li>函数的参数本质是 <strong>浅拷贝</strong>，<strong>地址拷贝</strong></li><li><strong>不能改变原来数据的地址</strong><ul><li>字符串，数字；作为参数，原来的数据不会改变<ul><li>字符串和数字存储的是<strong>常量</strong></li></ul></li><li>列表，字典 和 自定义类实例化的对象<ul><li>列表，字典，和 自定义对象 是 一段内存地址</li><li>不能改变地址，<strong>但是可以改变内部元素存储的地址</strong><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5></li></ul></li></ul></li></ul><ol><li>私有变量<ul><li>__变量: 变量前面<strong>加双下划线</strong></li><li>只能在类定义的内部修改，<strong>对象不能随意修改</strong>，只能通过set和get函数获取和修改</li><li>私有变量在内部实际存储的是<code>_classname__私有变量</code></li><li><img src="/2019/10/01/Python面对对象编程1/b94530b4.png" alt="私有变量"></li><li>意义<ul><li>保护数据，设计权限</li></ul></li></ul></li><li>私有方法<ul><li>同私有变量一样，禁止被人随意使用</li><li>私有方法 <code>__方法名</code>，在方法名前加__双下划线，拒绝外部访问</li><li>同理，私有方法可以使用_classname__方法访问</li></ul></li><li>私有的本质<ul><li>私有变量的本质就是讲方法和属性的名称重新命名了</li><li><code>__ ----&gt; _ClassName__</code></li></ul></li></ol><h4 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h4><ul><li>窗体模块,界面  </li></ul><h4 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h4><ul><li>操作系统的系统进程</li><li>通过消息原理控制操作系统</li><li>所有的windows应用都是消息驱动的<ul><li>所有的操作都被当做消息处理</li><li>进程被放到一张表中，等待消息</li><li>windows系统提供一个死循环，检测鼠标，键盘，每检测到一个操作，添加对应的消息</li></ul></li><li>消息循环<ul><li>得到消息之后，会将信息传递给所有的进程队列</li><li>哪个进程可以执行，就执行</li><li>callback  <strong>消息触发进程 消息回调机制</strong></li></ul></li></ul><h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><ul><li><p>关键字 try except else finally</p></li><li><p>异常和错误</p><ul><li><p>错误Error：大多指语法错误:解释器检查出来的</p><ul><li>常见错误<ul><li>常见错误：</li><li>name Error 变量没定义</li><li>Systax Error 语法错误</li><li>IO Error 文件错误</li><li>Zero DivisionError 10/0,除零错误</li><li>Value Error 值错误，例如a = int（‘aa’）</li><li>keyboard Interrupt 强制终止程序产生，ctrl+c强制终止程序运行</li></ul></li></ul></li><li><p>异常Exception、：不完整或者不合法输入或者计算出现问题</p><ul><li>异常产生，检查到错误且解释器认为是异常，抛出异常</li><li>异常处理，截获异常，忽略或终止程序处理异常</li></ul></li><li><p>处理异常</p><ul><li>语法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    语句块</span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">1</span>：</span><br><span class="line">    处理语句</span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">2</span>:</span><br><span class="line">    处理语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有出现异常，执行的语句</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    一定执行的语句</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>raise</p><ul><li>显示的引发异常<ul><li>可以是<strong>非语法的异常</strong>，自己设定的异常</li></ul></li><li>一旦执行raise语句，后面的语句不会再执行，程序结束</li><li>raise 的参数不能被except处理</li><li><code>raise [Exception [, args [, traceback]]]</code></li></ul></li></ul><h4 id="关键字-with-as"><a href="#关键字-with-as" class="headerlink" title="关键字 with as"></a>关键字 with as</h4><ul><li>根据上下文管理，可以自动的关闭打开的文件 </li></ul><h4 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a>assert 断言</h4><ul><li>判断一个表达式</li><li>在表达式为False时触发异常</li><li><code>assert expression [, arguments]</code> </li><li>等价 <code>if not expression:  raise AssertionError(arguments)</code></li><li>AssertionError: 被除数不能为0</li><li>对 raise的 进一步细化<ul><li>表达式为Flase的情况下触AssertError</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面对对象的编程思想&quot;&gt;&lt;a href=&quot;#面对对象的编程思想&quot; class=&quot;headerlink&quot; title=&quot;面对对象的编程思想&quot;&gt;&lt;/a&gt;面对对象的编程思想&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数是对代码块的抽象，代码重用&lt;/li&gt;
&lt;li&gt;面向对象编程是对&lt;st
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python文件读写</title>
    <link href="http://yoursite.com/2019/10/01/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://yoursite.com/2019/10/01/Python文件读写/</id>
    <published>2019-10-01T14:58:49.000Z</published>
    <updated>2019-10-01T15:13:11.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><ol><li>str<ul><li>返回一个<strong>用户易读</strong>的表达形式</li></ul></li><li>repr<ul><li>返回一个<strong>解释器易读</strong>的表达形式<ul><li>字符串 带引号和转义</li></ul></li><li>返回<strong>包含对象的可打印形式的字符串</strong></li><li>可以处理任何类型，表示类型</li><li>返回<strong>对象的字符串形式</strong><ul><li>字符串当作一个对象，再次当作普通对象处理</li><li>其他类型的也是一致的</li></ul></li><li>eval(repr(A)) == A</li><li>调用<strong>repr</strong> 函数</li><li>compute the “official” string representation of an object</li><li>Return the <strong>canonical</strong> string representation of the object.</li></ul></li><li>对比<ul><li>对于一般数据而言，相同</li><li>在命令行中对比比较好</li><li>str统一转换为字符串，<strong>看不到类型</strong></li></ul></li></ol><h5 id="标准输入和输出"><a href="#标准输入和输出" class="headerlink" title="标准输入和输出"></a>标准输入和输出</h5><ul><li><strong>标准的输入和输出是</strong> <em>控制台</em></li><li>可以使用<strong>重定向符号</strong> 将输入和输出定向到其他地方</li><li><code>shu.py &lt; 1.txt  &gt; 2.txt</code><ul><li>从1.txt 读入内容</li><li>向2.txt 输出内容</li></ul></li></ul><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="文件对象-file-object"><a href="#文件对象-file-object" class="headerlink" title="文件对象 file object"></a>文件对象 file object</h4><ul><li>File objects are also called <strong>file-like objects</strong> or <strong>streams.</strong></li><li>&lt;<strong>_io.BufferedReader</strong> name=’E:\项目\Python\zhaolong\study\09-19\txt\6.chuci.txt’</li><li>类文件对象或流</li><li>三类文件对象<ul><li>raw binary files, buffered binary files and text files.</li><li>二进制文件（原始二进制文件，缓冲二进制文件），文本文件</li></ul></li><li>将面向文件的API暴露给底层资源对象</li><li>根据创建文件的方式，文件对象可以调教对真是存储文件或其它类型存储或通信设备的访问</li><li><strong>创建文件对象的规范方法是open()函数</strong></li></ul><ol><li>open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) <ul><li>Open file and return a <strong>corresponding file object</strong>. If the file cannot be opened, an OSError is raised.</li><li>file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened</li><li>or an integer file descriptor of the file to be wrapped. </li><li>(If a file descriptor is given, it is closed when the returned I/O object is closed, unless closefd is set to False.)</li><li>file 是一个<strong>类似路径的对象</strong><ul><li>要打开文件的路径名(绝对路径或者当前工作目录的相对路径)</li><li>整型的文件描述符</li></ul></li><li>mode is an optional string that specifies the mode in which the file is opened<ul><li>mode 可选，默认’r’ 同义词 <code>rt</code> read text</li><li>指定文件的打开模式</li><li><img src="/2019/10/01/Python文件读写/b86e9a1d.png" alt="常见mode"></li></ul></li><li>错误处理机制<ul><li>errors：如何处理编码和解码错误</li><li><img src="/2019/10/01/Python文件读写/86a02076.png" alt="错误处理"></li><li>常用的时<ul><li>ignore：忽略错误，强制解码</li></ul></li></ul></li><li>Python区分文本和二进制I/O，<ul><li>二进制打开模式’b’，返回bytes，没有任何编码</li><li>文本打开模式<code>t</code>,返回str，使用平台相关的编码或者指定的编码进行解码 </li><li>windows系统文本中默认的gbk编码格式,open中没有标明编码格式的话，默认使用系统编码格式<ul><li>UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x9f in position 22: illegal multibyte sequence </li></ul></li><li><img src="/2019/10/01/Python文件读写/a85bdfe5.png" alt="win10默认的编码"></li><li>默认中文环境<em>gbk，ansi</em>，<strong>系统自动寻找编码解码和编码</strong></li><li>使用多个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码;<ul><li>在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码</li><li>不同 ANSI 编码之间互不兼容</li></ul></li><li>python的默认编码也是 utf-8<ol start="2"><li>中文写入</li></ol></li></ul></li><li>中文需要使用编码</li><li>常用’’utf-8’或者’gbk’</li><li>使用utf-8编码，以二进制写入，<strong>不会受平台影响</strong></li><li>不同的编码会导致编码失败，主要时某个编码的字符，其他编码没有<ul><li>解决方案: 在编码重合度很高的情况下，忽略编码错误，也可以解码，但也可能出现完全乱码</li></ul></li><li><img src="/2019/10/01/Python文件读写/462625a9.png" alt="win10的文件编码"></li><li><img src="/2019/10/01/Python文件读写/dbf2d65e.png" alt="win10文件的本质"></li><li>由于系统编码的不确定性，<strong>指定编码</strong>，或者直接<strong>进行二进制写入</strong></li><li><strong>编码必须保持一致</strong></li></ul></li><li>缓存区 buffer<ul><li><strong>数据写入文件非实时的</strong></li><li>用于设置 <strong>缓冲 策略</strong><ul><li>0- 关闭缓存 - 仅在二进制模式下</li><li>1- line buffer 行缓存，仅在文本模式下可用</li><li>&gt; 1 指定大小的块缓存区 byte</li><li>buffering is an optional integer used to set the buffering policy.</li><li>Pass 0 to switch buffering off (only allowed in binary mode), </li><li>1 to select line buffering (only usable in text mode), </li><li>and an integer &gt; 1 to indicate the size in bytes of a fixed-size chunk buffer.</li></ul></li><li>默认情况<ol><li>Binary files are buffered in fixed-size chunks; 4096 or 8192 bytes long.</li><li>“Interactive” text files (files for which isatty() returns True) use line buffering.</li><li>Other text files use the policy described above for binary files.</li></ol></li><li>flush 方法<ul><li>实时写入</li><li><strong>如果程序未正常结束，也可以保证数据已经写入</strong></li></ul></li><li><img src="/2019/10/01/Python文件读写/37c41898.png" alt="文件读取写入"></li></ul></li><li>读取文件<ul><li>内存模式 read readlines</li><li>硬盘模式：readline</li></ul> 4.1 read(size=-1) <pre><code>* Read and return at most size characters from the stream as a single str. * If size is negative or None, reads until EOF.* 按照size读取字符，作为一个新的字符串* 如果size为空，则 全部去读</code></pre> 4.2 readline(size=-1) <pre><code>* Read until newline or EOF and return a single str. * If the stream is already at EOF, an empty string is returned.* If size is specified, **at most size characters will be read*** 读取一行或者到eof* size指定，读取指定数量的字符,但是遇到换行符也会停止    * 意思就是 相当于 由**两个换行符**        * 指定的字符数 size        * 换行符 </code></pre> 4.3 readlines(hint=-1) <pre><code>* Read and return a list of lines from the stream. * hint can be specified to control the number of lines read: * no more lines will be read if the total size (in bytes/characters) of all lines so far exceeds hint.* 返回一个由行组成的列表，每行包含换行符* 参数是行数，指定读取的行数(包含这次**已读取的行数**)</code></pre></li><li>文件指针<ul><li>文件对象是<strong>流对象</strong></li><li>包含 <strong>文件指针</strong><ul><li><strong>会指向当前读取的字符</strong></li><li><strong>文件指针只会向后运动，不会向前移动</strong></li><li>当文件指针指向EOF，文件读取结束</li></ul></li><li>函数<ol><li>tell() <ul><li>Return the current stream position as <strong>an opaque number.</strong> </li><li>The number does not usually represent a number of bytes in the underlying binary storage.</li><li>返回当前的文件指针<strong>指向的位置</strong>,并不是字符数</li><li>该数字通常不代表底层二进制存储中的多个字节。 汉字 3  符号  3  从0开始</li></ul></li><li>seek(offset[, whence]) <ul><li>设置当前块中文件指针的位置</li><li>whence 可选<ul><li>0 默认 绝对位置</li><li>1 相对于当前的位置  io.UnsupportedOperation: can t do nonzero cur-relative seeks<ul><li>file 不做非0相对搜索</li></ul></li><li>2 相对于文件EOF</li></ul></li><li>常用作<strong>回到文件开头</strong>,末尾不是EOF，而是 数值</li></ul></li></ol></li></ul></li><li>文件对象的遍历<ul><li>文件对象拥有<code>__next__</code>和<code>__iter__</code>特殊方法，支持迭代协议，属于<strong>可迭代对象</strong></li><li>for line in fileobj:<ul><li>不等同于 fileobj.readlins（）,一次性读取到内存中</li><li>而是按照next函数，<strong>一行行的取出数据</strong><h3 id="pickle-数据序列和反序列化，常用于持久化，保存到文件"><a href="#pickle-数据序列和反序列化，常用于持久化，保存到文件" class="headerlink" title="pickle 数据序列和反序列化，常用于持久化，保存到文件"></a>pickle 数据序列和反序列化，常用于持久化，保存到文件</h3></li></ul></li></ul></li></ol><ul><li>pickle Python object serialization</li><li>The pickle module implements binary protocols for serializing and de-serializing a Python object structure</li><li><strong>pickle模块为python对象结构实现序列化和反序列化的二进制协议</strong></li><li>“Pickling” is the process whereby a Python object hierarchy is converted into a byte stream</li><li>pickle 是 <strong>将python对象层次结构转化为字节流的过程</strong></li><li>unpickle 是一个反向操作<ul><li>即将字节流(来自二进制文件或类似字节的对象)转换回对象层次结构</li></ul></li></ul><ol><li>通过pickle模块的序列化操作我们<strong>能够将程序中运行的对象信息保存到文件中去</strong>，永久保存</li><li>通过pickle模块的反序列化操作，我们能够<strong>从文件中创建上一次程序保存的对象</strong></li></ol><h5 id="序列化函数-dump"><a href="#序列化函数-dump" class="headerlink" title="序列化函数 dump()"></a>序列化函数 dump()</h5><ul><li>pickle.dump(obj, file, protocol=None, *, fix_imports=True) <ul><li>Write a pickled representation of obj to the open file object file. </li><li>This is equivalent to Pickler(file, protocol).dump(obj).</li><li><strong>将对象的pickle表示写入打开文件对象中</strong></li><li>protocol 是支持的协议</li><li>file 对象必须是fileobj，拥有write方法</li></ul></li><li>pickle.dumps(obj, protocol=None, *, fix_imports=True) <ul><li>Return the pickled representation of the object as a bytes object, instead of writing it to a file.</li><li>返回对象的pickle表示，而不是写入文件<h5 id="反序列化函数-load"><a href="#反序列化函数-load" class="headerlink" title="反序列化函数 load()"></a>反序列化函数 load()</h5></li></ul></li><li>pickle.load(file, *, fix_imports=True, encoding=”ASCII”, errors=”strict”) <ul><li>Read a pickled object representation from the open file object file and return the reconstituted object hierarchy specified therein.</li><li>This is equivalent to Unpickler(file).load().</li><li><strong>从打开的文件对象中读取经过pickle的对象，并且重构Python对象类型</strong></li><li>file 必须提供read()和readline()方法</li></ul></li><li>pickle.loads(bytes_object, *, fix_imports=True, encoding=”ASCII”, errors=”strict”) <ul><li>Read a pickled object hierarchy from a bytes object and return the reconstituted object hierarchy specified therein.</li><li><strong>从字节对象中读取picked的对象，并且重构Python对象类型</strong></li></ul></li></ul><h4 id="os-模块-操作系统接口"><a href="#os-模块-操作系统接口" class="headerlink" title="os 模块  操作系统接口"></a>os 模块  操作系统接口</h4><ul><li>This module provides a portable way of using operating system dependent functionality. </li><li>os.popen() 和 os.system()<ul><li>同样可以指向指令</li><li>os.system无法获取返回的结果</li><li>os.popen() 返回一个<em>文件对象*</em>，连接的命令,</li><li>Python 把所有的设备当作文件处理，<strong>文件的重定向</strong><ul><li>返回的对象可以读取和写入，根据mode确定</li><li>返回的是字符串对象，而不是bytes </li></ul></li></ul></li><li>文件夹编程<ul><li>os.listdir()<ul><li>遍历文件夹下的所有文件</li></ul></li><li>os.mkdir()<ul><li>创建一个文件夹</li><li>必须一层层的创建，不能跨层创建</li></ul></li><li>os.rmdir()<ul><li>删除文件夹</li><li>只能删除空目录</li></ul></li><li>os.remove()<ul><li>删除文件</li></ul></li><li>os.rename()<ul><li>重命名</li></ul></li><li>os.path.isfile()</li><li>os.path.isdir()<ul><li>判断是否是文件或目录</li></ul></li></ul></li></ul><h4 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h4><ul><li>itertools.permutations(iterable, r=None) <ul><li>返回元素长度为r的排列</li><li>包含 元素相同，顺序不同 的情况</li><li>r  默认None 函数使用全部长度 </li><li>r &lt;= len(iterable)</li></ul></li><li>itertools.combinations(iterable, r) <ul><li>返回元素长度为r的组合</li><li>没有顺序</li></ul></li><li>注意<ul><li>返回的都是<strong>迭代器</strong></li><li>必须使用list转化为list元素</li></ul></li><li>itertools.product(*iterables, repeat=1) <ul><li>生成可迭代对象的笛卡尔积，repeat指元素的个数 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;字符串的输出&quot;&gt;&lt;a href=&quot;#字符串的输出&quot; class=&quot;headerlink&quot; title=&quot;字符串的输出&quot;&gt;&lt;/a&gt;字符串的输出&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;str&lt;ul&gt;
&lt;li&gt;返回一个&lt;strong&gt;用户易读&lt;/strong&gt;的表达形式&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python列表，字典，集合详解</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Python列表，字典，集合详解/</id>
    <published>2019-09-23T07:26:40.000Z</published>
    <updated>2019-10-01T15:11:57.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表详细-元组详细-集合详细-字典详细-迭代器"><a href="#列表详细-元组详细-集合详细-字典详细-迭代器" class="headerlink" title="列表详细  元组详细  集合详细  字典详细 迭代器"></a>列表详细  元组详细  集合详细  字典详细 迭代器</h3><p>object.<strong>hash</strong>(self)<br>    * Called by built-in function hash() and for operations on members of hashed collections <strong>including set, frozenset, and dict</strong>.</p><a id="more"></a><p><code>hashable</code><br>    An object is hashable if it has a hash value which <strong>never changes</strong> during its lifetime<br>    (it needs a <strong>hash</strong>() method), and can be compared to other objects (it needs an <strong>eq</strong>() method).<br>    <strong>Hashable objects which compare equal must have the same hash value</strong>.<br>    Hashability makes an object usable as a dictionary key and a set member,<br>    because these <strong>data structures use the hash value internally.</strong><br>    hashable 可以用做dict的key和set的number，这些数字类型内部元素的可以hashbale</p><pre><code>&gt; Most of Python’s immutable built-in objects are hashable;&gt; mutable containers (such as lists or dictionaries) are not; &gt; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable.</code></pre><p>   不可变内置数据类型 是 hashable :str  frozenset<br>   可变容器类型 是 unhashable: list  dict    <code>unhashable type: &#39;set&#39;</code><br>   不可变容器类型元素是hashable的话，他们才是hashable：tuple fronzenset</p><ul><li><img src="/2019/09/23/Python列表，字典，集合详解/5cd91dcb.png" alt="哈希"><br>Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id().</li></ul><h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h4><h5 id="列表的构造"><a href="#列表的构造" class="headerlink" title="列表的构造"></a>列表的构造</h5><ol><li>使用<strong>方括号</strong><code>[]</code><strong>表示空列表</strong></li><li><strong>使用方括号<code>[]</code>,其中逗号<code>,</code>分割元素</strong></li><li>使用<strong>列表解析</strong>，<code>[x for x in iterable]</code></li><li>使用<strong>类型构造函数</strong>，<code>list()</code>或者<code>list(iterable)</code><ul><li>使用构造函数构造列表，<strong>列表的元素和iterable的元素相同且顺序相同</strong></li><li>没有参数，返回一个空列表<h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5></li></ul></li></ol><ul><li><img src="/2019/09/23/Python列表，字典，集合详解/11117d30.png" alt="常规的内存结构"></li><li><img src="/2019/09/23/Python列表，字典，集合详解/58be7780.png" alt="list的内存结构"></li><li>list是<strong>内存中的一段地址的集合</strong>，<strong>赋值是从一个地址的集合转到另一个地址的集合</strong><ul><li><strong>字符串存放的是一个地址</strong>，<strong>list是一堆地址</strong></li></ul></li><li><strong>list内部的存储的是元素的地址，通过索引进行操作，引用</strong></li><li><strong>list内部的元素是可以变化的，可以添加元素，删除元素等操作，可以单独修改引用地址</strong></li><li><strong>list内部的元素类型是不固定的，list只记录元素的地址，通过索引调用</strong></li><li><strong>修改单独元素不会影响list的值，只有整体赋值才能影响list</strong>，也就是将list指向新的地址段</li></ul><h6 id="list特点"><a href="#list特点" class="headerlink" title="list特点"></a>list特点</h6><ul><li>多个变量组成的集合，每个变量可以<strong>存储不同的地址</strong><ul><li><strong>可以包含不同类型的变量地址</strong></li></ul></li><li>对list中的元素进行增删改，不会影响list</li><li><strong>每个元素都有自己的独立地址</strong></li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><ul><li><strong>从0开始，通过索引操作元素</strong>，修改元素</li><li>索引：[0-len(list)-1] 或者 [0,-1]</li><li>正向索引和负向索引<ul><li>负向索引 <code>-m = len(list)-m</code></li></ul></li><li>索引的切片操作[m,n] 包含m，不包含n</li></ul><h5 id="⚠-循环"><a href="#⚠-循环" class="headerlink" title="⚠ 循环"></a>⚠ 循环</h5><ol><li>遍历元素  <code>for x in list:</code><ul><li>x是元素的值，而不是元素，data = mylist[1]，元素的copy，副本</li><li><strong>只能打印列表元素的值</strong></li><li>不能对元素进行修改等操作</li></ul></li><li>下标循环   <code>for i in range(len(list))</code><ul><li>i – 是<strong>索引</strong></li><li>list[i] 可以<strong>操作元素</strong>，包括打印输出，修改操作</li></ul></li></ol><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><ul><li>del 是关键字 属于<strong>声明</strong></li><li>del是递归定义的，与定义赋值的方式非常相似</li><li><strong>删除列表会自左向右递归删除每个目标</strong></li><li>Deletion of a name removes the binding of that name from the local or global namespace, depending on whether the name occurs in a global statement in the same code block.</li><li>删除名称将删除名称与本地或全变量的绑定</li><li>相当于内存回收</li><li>删除list的元素的时候，会出现索引越界的问题 del list[1]</li><li><img src="/2019/09/23/Python列表，字典，集合详解/61eaf59d.png" alt="删除索引越界"><ul><li>添加break语句，不会出现越界的问题</li></ul></li><li><strong>删除一个元素之后，索引及时变化，会向左移动</strong><ul><li>list是一个比较紧凑的数据结构</li></ul></li></ul><h5 id="列表的运算符"><a href="#列表的运算符" class="headerlink" title="列表的运算符"></a>列表的运算符</h5><ol><li>in / not in<ul><li>成员运算符，判断是否存在与列表中</li><li>只会判断第一层的元素</li><li>True False</li></ul></li><li>+<ul><li>列表的<strong>元素拼接</strong></li><li>归并</li></ul></li><li>*<ul><li>列表的<strong>元素重复</strong></li></ul></li></ol><h4 id="列表的嵌套"><a href="#列表的嵌套" class="headerlink" title="列表的嵌套"></a>列表的嵌套</h4><ul><li>列表的<strong>元素是列表</strong></li><li><strong>嵌套列表的访问需要使用嵌套for语句</strong></li><li>表示<strong>矩阵</strong></li><li>常见的嵌套列表是<strong>单个元素和列表元素同时存在</strong>，打印时小心处理,str有索引，但是输出不合理，int没有索引</li></ul><h5 id="isinstance-object-classinfo"><a href="#isinstance-object-classinfo" class="headerlink" title="isinstance(object, classinfo)"></a>isinstance(object, classinfo)</h5><ul><li>判断object是否是classinfo的实例</li><li>Return true if the <strong>object argument is an instance of the classinfo argument</strong>, or of a (direct, indirect or virtual) subclass thereof.</li></ul><h5 id="列表的常见方法"><a href="#列表的常见方法" class="headerlink" title="列表的常见方法"></a>列表的常见方法</h5><ul><li>Lists implement all of the common and mutable sequence operations.</li><li><strong>列表实现所有的常见和可变序列操作</strong></li><li>支持基本的序列操作</li></ul><p>1.append()<br>    * 添加元素到最后一个位置<br>    * <strong>把参数当作一个元素</strong></p><ol start="2"><li>index()<ul><li>查找第一个出现的索引</li><li><strong>只会查找list的元素，不会进入元素内部查找</strong></li></ul></li><li>count()<ul><li>统计元素出现的次数</li></ul></li><li>reverse()<ul><li>将列表元素反转</li><li>顺序反转，<strong>不排序</strong></li></ul></li><li>sort(*, key=None, reverse=False) <ul><li>按照元素的大小进行排序</li><li>reverse=True 从大到小</li><li>不合适嵌套的列表</li></ul></li><li>clear()<ul><li>序列的操作</li><li>清空列表</li></ul></li><li>pop()<ul><li>弹出最后一个元素</li><li>返回最后一个元素，并且列表也会发生变化</li></ul></li><li>remove()<ul><li>删除列表中的默认元素</li><li>没有返回值</li></ul></li><li>insert() <ul><li>相当于 s[i:i] = [x])</li><li><strong>在索引位置插入元素，之前的后移</strong></li></ul></li></ol><h5 id="list的拷贝"><a href="#list的拷贝" class="headerlink" title="list的拷贝"></a>list的拷贝</h5><ul><li>python是地址赋值，地址引用</li><li>在list中<ul><li><code>=</code>简单的地址引用</li><li><strong>两个变量指向同一个list</strong></li><li>is -&gt; True</li><li><img src="/2019/09/23/Python列表，字典，集合详解/998b897f.png" alt="引用赋值"></li><li>节约内存</li><li>数据共享，一个修改，另一个变量的值也发生变化了</li></ul></li></ul><ol start="2"><li>shadow copy 浅拷贝<ul><li>s.copy()</li><li>creates a shallow copy of s (same as s[:])</li><li>浅拷贝  类似第一层的切片</li><li>第二层列表共享</li><li><img src="/2019/09/23/Python列表，字典，集合详解/c9321bf6.png" alt="浅拷贝"></li><li>和 copy库中的copy.copy 功能一致</li></ul></li><li>deep copy 深拷贝<ul><li>递归拷贝对象</li><li>所有的数据都保存为副本</li><li>数据之间独立，不共享</li></ul></li></ol><ul><li>浅复制和深复制之间的区别<strong>仅与复合对象</strong>（包含其他对象的对象，如列表或类实例）相关</li><li>A shallow copy constructs a new compound object and then (to the extent possible) <strong>inserts references into it</strong> to the objects found in the original.</li><li>A deep copy constructs a new compound object and then, <strong>recursively, inserts copies into it</strong> of the objects found in the original.</li><li>浅拷贝是将它的<strong>引用</strong>插入到原始对象中</li><li>深拷贝是<strong>递归方式将复制对象</strong>插入到原始对象中找到的对象<ul><li>深拷贝会复制它可能复制的所有内容</li><li>递归对象（直接或间接包含对自身的引用的复合对象）可能会导致递归循环。</li></ul></li></ul><h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h4><ul><li>元组属于<strong>不可变序列</strong>，用于<strong>存储异构数据的集合</strong></li><li>构造<ol><li><code>()</code> 表示空元组</li><li>单例元组使用   a trailing comma for a singleton tuple <strong>末尾逗号</strong> <code>（a,）</code></li><li>使用逗号分割元素</li><li>函数内置函数tuple()</li></ol><ul><li>Note that it is <strong>actually the comma which makes a tuple</strong>, not the parentheses. </li><li><strong>本质上是由逗号确定元组的</strong></li><li><strong>可以不加括号</strong>，但是不常用</li></ul></li><li>本质<ul><li>元素属于序列，基本满足序列的操作</li><li>通过索引进行元素的操作，只能打印</li><li><strong>元素 不可变</strong></li><li><img src="/2019/09/23/Python列表，字典，集合详解/37ed335f.png" alt="元组内存结构"></li><li>和list对比，存储的是<strong>地址常量</strong>，而且list中存储的是<strong>地址变量</strong></li></ul></li><li>索引<ul><li>正向索引</li><li>负向索引</li><li>切片操作 左开右闭合 [)</li></ul></li><li>元素符号<ul><li><ul><li>拼接 </li></ul></li><li><ul><li>复制</li></ul></li><li>in 成员操作符<ul><li>in 判断第一层的元素</li></ul></li></ul></li><li>循环<ul><li>元素遍历循环</li><li>下标循环</li></ul></li><li>max,min<ul><li>返回最大，最小的元素</li><li>如果有嵌套的，报错</li></ul></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>A set object is an <strong>unordered collection</strong> of <strong>distinct hashable objects</strong></li><li><strong>不同哈希对象的无序集合</strong></li><li><strong>不重复元素的无序集合</strong></li><li>不支持索引<ul><li>用途<ul><li>成员资格测试</li><li>从序列中删除重复项</li><li>数学运算（差集，交集，补集）</li></ul></li></ul></li><li><strong>无序</strong>集合，不记录元素的元素的位置和插入顺序，不支持索引，切片或其他类似序列的操作</li><li>有两种类型<code>set</code>和<code>frozenset</code></li></ul><ol><li>class set([iterable]) <ul><li>The set type is <strong>mutable</strong> — the contents <strong>can be changed</strong> using methods like add() and remove(). </li><li>Since it is mutable, it has <strong>no hash value</strong> and cannot be used as either a dictionary key or as an element of another set. </li></ul></li><li>class frozenset([iterable]) <ul><li>The frozenset type is <strong>immutable and hashable</strong> — its contents cannot be altered after it is created; </li><li>it can therefore be used as a dictionary key or as an element of another set.<h5 id="构造set"><a href="#构造set" class="headerlink" title="构造set"></a>构造set</h5></li></ul></li></ol><ul><li>使用大括号<code>{}</code>定义</li><li>元素之间用<strong>逗号</strong>隔开</li><li>set([iterable])  可迭代对象拆分成了 集合</li><li><code>{}</code> 定义的是<strong>dict</strong><ul><li>空set使用set()定义  输出也是 <code>set()</code></li><li>set(set)：使用set重新创建set，<strong>两个不一致</strong></li></ul></li><li>set集合没有顺序</li><li>从字典转换成集合 注意：<strong>只有key值</strong></li><li><strong>集合不能进行单独元素的操作</strong></li></ul><h5 id="set的函数"><a href="#set的函数" class="headerlink" title="set的函数"></a>set的函数</h5><ol><li>add(elem) <ul><li>Add element elem to the set.</li><li>注意 set的元素是hashable的，所以不能添加list和set，</li></ul></li><li>update(*others) <ul><li>Update a set with the <strong>union</strong> of itself and others</li><li><strong>参数是iterable</strong> TypeError: ‘int’ object is not iterable</li><li>会将可迭代对象的每个元素和原set进行union操作</li></ul></li><li>remove<ul><li>删除元素,但是元素不存在时，会报错</li><li>KeyError: 1</li><li>Remove an element from a set; it must be a member.</li><li>If the element is not a member, raise a KeyError.</li></ul></li><li>discard(elem) <ul><li>Remove element elem from the set if it is present.</li><li>删除元素，如果存在与set中，则删除</li><li>不存在与set中，do nothing</li></ul></li><li>pop<ul><li>Remove and return an arbitrary element from the set. Raises KeyError if the set is empty</li><li>从集合中删除和返回<strong>任意元素</strong></li><li>集合为空，会引发keyError错误</li></ul></li><li>clear <ul><li>Remove all elements from the set.</li></ul></li><li>difference(*others) <ul><li>set - other - … </li><li>Return a new set with elements <strong>in the set that are not in the others.</strong></li><li>返回一个集合，元素在set中，而不在other中</li><li>表示差集 A.difference(B) == A-B</li></ul></li><li>isdisjoint(other) <ul><li>Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set.</li><li><strong>没有交集</strong></li></ul></li></ol><h5 id="set的循环"><a href="#set的循环" class="headerlink" title="set的循环"></a>set的循环</h5><ul><li>没有索引操作，只能使用in操作符<strong>元素遍历</strong></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>tuple</li><li>set</li><li>list</li></ul><h5 id="set无法单独操作每个元素"><a href="#set无法单独操作每个元素" class="headerlink" title="set无法单独操作每个元素"></a>set无法单独操作每个元素</h5><ul><li>循环遍历中的是 <strong>副本</strong></li><li>可以修改副本，但是修改不了原本</li><li><strong>如果要操作单个元素，可以转化成list，修改之后，再次转换回来</strong></li></ul><h5 id="集合的运算符"><a href="#集合的运算符" class="headerlink" title="集合的运算符"></a>集合的运算符</h5><ol><li><p>-</p><ul><li>差集</li><li>A - B：A中存在的元素，B中不存在</li></ul></li><li><p>&amp;</p><ul><li>交集</li><li>A &amp; B：元素存在于A中，也存在B中</li><li>和集合的前后顺序无关</li></ul></li><li><p>|</p><ul><li>并集</li><li>返回一个集合</li><li>A | B: 元素存在与A或者B中</li></ul></li><li><p>^</p><ul><li>并集 - 交集</li><li>A ^ B: 分别存在A或者B集合中</li></ul></li><li><p>==</p><ul><li>判断A和B元素是否相等</li><li>只要元素分别存在与两个集合中返回True</li><li>不考虑顺序，set没有顺序</li></ul></li><li><p>in </p><ul><li>用于<strong>判断元素是否是否属于集合</strong></li><li><strong>如果是 set in set 返回False</strong>11<h5 id="集合的关系运算符"><a href="#集合的关系运算符" class="headerlink" title="集合的关系运算符"></a>集合的关系运算符</h5></li></ul></li><li><p>issubset(other)  包含</p><ul><li>set &lt;= other </li><li>Test whether every element in the set is in other.</li><li>测试set中的元素是否存在与other</li><li>set &lt; other </li><li>Test whether the set is a proper subset of other, that is, <strong>set &lt;= other and set != other</strong>.</li><li>测试set的是不是other的子集，</li></ul></li><li><p>issuperset(other)   被包含</p><ul><li><p>set &gt;= other </p></li><li><p>Test whether every element in other is in the set.</p></li><li><p>set &gt; other </p></li><li><p>Test whether the set is a proper superset of other, that is, set &gt;= other and set != other.</p></li></ul></li></ol><h4 id="mapping-type-—-gt-dict"><a href="#mapping-type-—-gt-dict" class="headerlink" title="mapping type —&gt; dict"></a>mapping type —&gt; dict</h4><ul><li>映射</li><li>A mapping object maps hashable values to arbitrary objects. </li><li>映射对象：<strong>可哈希值映射到任意的对象</strong></li><li>mapping 是可变类型，目前标准映射只有dict</li></ul><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul><li>Key：几乎任意值，但是必须是可哈希的</li><li>Value：任意值<ul><li>list，dict和set 不能作为key</li></ul></li><li>Dictionaries can be created by <strong>placing a comma-separated list of key</strong>: <strong>value pairs within braces</strong></li><li>可变数据类型，存储任意类型对象</li><li>集合的加强版，可以使用key调用value；key和set的元素类似</li><li>key的value<strong>可以被覆盖，按照录入顺序</strong><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5></li><li>class dict(**kwarg)  关键字参数<ul><li>name=”zhaolong” 其中<strong>前一个不需要引号</strong></li></ul></li><li>class dict(mapping, **kwarg)   映射类型<ul><li>如 zip函数</li></ul></li><li>class dict(iterable, **kwarg)   可迭代一对<ul><li>[(,)]</li></ul></li><li>dict() 或者 {} <strong>创建空字典</strong></li><li>通过key值引用value dict[key]</li></ul><h5 id="映射函数"><a href="#映射函数" class="headerlink" title="映射函数"></a>映射函数</h5><ul><li><p>zip(*iterables) </p><ul><li><p>参数是多个可迭代数据，或者可迭代的列表</p></li><li><p>Make an iterator that aggregates elements from each of the iterables.</p></li><li><p><strong>根据多个迭代对象的对应元素创建一个迭代对象</strong></p></li><li><p>返回一个<strong>元组的迭代器</strong>，<strong>元素来自与参数迭代对象的对应元素</strong></p></li><li><p>The iterator stops when the shortest input iterable is exhausted. </p></li><li><p>当其中任意一个可迭代对象停止时，结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span><span class="params">(*iterables)</span>:</span></span><br><span class="line"><span class="comment"># zip('ABCD', 'xy') --&gt; Ax By</span></span><br><span class="line">sentinel = object()</span><br><span class="line">iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> iterables]</span><br><span class="line"><span class="keyword">while</span> iterators:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterators:</span><br><span class="line">        elem = next(it, sentinel)</span><br><span class="line">        <span class="keyword">if</span> elem <span class="keyword">is</span> sentinel:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result.append(elem)</span><br><span class="line">    <span class="keyword">yield</span> tuple(result)</span><br></pre></td></tr></table></figure></li><li><p>zip() 函数可用于解压缩列表</p></li></ul></li></ul><h5 id="字典的更新"><a href="#字典的更新" class="headerlink" title="字典的更新"></a>字典的更新</h5><ol><li>in </li></ol><ul><li><strong>判断键值是否存在</strong>，不判断值</li><li>key in d <ul><li>Return True if d has a key key, else False.</li></ul></li><li>key not in d <ul><li>Equivalent to not key in d.</li></ul></li></ul><p>2.del d[key]<br>    * Remove d[key] from d. Raises a KeyError if key is not in the map.</p><ol start="3"><li>clear() <ul><li>Remove all items from the dictionary.</li></ul></li><li>len(d) <ul><li>Return the number of items in the dictionary d.</li></ul></li><li>copy() <ul><li>Return a shallow copy of the dictionary.</li></ul></li><li>get(key[, default]) <ul><li>Return <strong>the value for key</strong> if key is in the dictionary, else default.</li><li>If default is not given, it <strong>defaults to None</strong>, so that this method <strong>never raises a KeyError</strong>.</li></ul></li><li>items() <ul><li>Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects.</li></ul></li><li>keys() <ul><li>Return a new view of the dictionary’s keys. See the documentation of view objects.</li></ul></li><li>values() <ul><li>Return a new view of the dictionary’s values. See the documentation of view objects.</li><li>a <strong>set-like object</strong> providing <strong>a view on D’s items</strong></li><li>都是可以迭代的 </li></ul></li><li>update([other]) <ul><li>Update the dictionary with the <strong>key/value pairs from other</strong>, </li><li>overwriting existing keys. Return None.</li><li>会使用参数dict的键值对更新dict，如果存在，覆盖；如果不存在，返回None</li><li>会更新dict</li></ul></li><li>setdefault(key[, default]) <ul><li>If key is in the dictionary, return its value. </li><li>If not, <strong>insert key with a value of default and return default</strong>. </li><li>default defaults to None.</li></ul></li></ol><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li><img src="/2019/09/23/Python列表，字典，集合详解/2eddd0a3.png" alt="迭代器原理"></li><li>迭代器协议<ul><li><strong>iter</strong></li><li><strong>next</strong></li><li>StopIteration</li></ul></li><li>常用在<code>for in</code>环境中</li><li>可迭代对象 和 迭代器 的协议稍微不一致</li><li><img src="/2019/09/23/Python列表，字典，集合详解/18542041.png" alt="可迭代对象"></li><li><img src="/2019/09/23/Python列表，字典，集合详解/a035e139.png" alt="迭代器"></li></ul><h4 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h4><h5 id="列表生成式：-x-for-x-in-range-100-一次性全部删除，浪费内存"><a href="#列表生成式：-x-for-x-in-range-100-一次性全部删除，浪费内存" class="headerlink" title="列表生成式：[x for x in range(100)]  一次性全部删除，浪费内存"></a>列表生成式：[x for x in range(100)]  一次性全部删除，<strong>浪费内存</strong></h5><ul><li>非常暴力的占用内存，严重浪费<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5></li><li>一次生成一个数据，节约内存</li><li>使用关键字 <code>yield</code>生成生成器函数</li><li>或者<strong>生成器表达式()</strong><h6 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h6></li><li>(x for x in range(100))</li><li>使用 next()</li></ul><h5 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h5><ul><li>和常规函数没有区别</li><li>但是 在内部使用了关键字 <code>yield</code></li><li>其中 函数名：函数</li><li>函数调用：函数名() 的类型时generator</li><li>第一次执行：到达yield 返回内存</li><li>第二次调用：继续上一次执行的地方继续执行</li><li>注意<ul><li>使用的时候，首先 将函数生成器赋值给变量，以防每次使用生成一个<strong>新的生成器</strong>  x=go()</li><li>yield 在函数常和for<strong>搭配使用</strong></li><li>生成器函数只能通过<code>next()</code>调用<ul><li>因为 函数名() 已经变成一个 generator 了</li><li>必须使用 next()</li></ul></li><li>常用于<strong>读取文件</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;列表详细-元组详细-集合详细-字典详细-迭代器&quot;&gt;&lt;a href=&quot;#列表详细-元组详细-集合详细-字典详细-迭代器&quot; class=&quot;headerlink&quot; title=&quot;列表详细  元组详细  集合详细  字典详细 迭代器&quot;&gt;&lt;/a&gt;列表详细  元组详细  集合详细  字典详细 迭代器&lt;/h3&gt;&lt;p&gt;object.&lt;strong&gt;hash&lt;/strong&gt;(self)&lt;br&gt;    * Called by built-in function hash() and for operations on members of hashed collections &lt;strong&gt;including set, frozenset, and dict&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串详解</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Python字符串详解/</id>
    <published>2019-09-23T07:19:37.000Z</published>
    <updated>2019-09-23T07:25:42.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串详解"><a href="#字符串详解" class="headerlink" title="字符串详解"></a>字符串详解</h3><h4 id="eval-和-evec"><a href="#eval-和-evec" class="headerlink" title="eval 和 evec"></a>eval 和 evec</h4><ol><li>eval：<ul><li>eval 语句用来计算存储在字符串中的<strong>有效表达式</strong></li><li>内置函数</li><li>可以转化为实数,<strong>只能处理字符串形式的表达式</strong></li><li>常见的使用：<code>num = eval(input(&quot;输入数据:&quot;))</code></li><li>The expression argument is parsed and evaluated as a Python expression </li><li><code>eval(&quot;2+2&quot;)</code></li><li><strong>参数是 “字符串”</strong></li><li>eval() arg 1 must be a string, bytes or code object</li><li><strong>将文本当作表达式使用</strong><a id="more"></a></li></ul></li><li>exec：<ul><li>exec 语句 用来执行存储在字符串或文件中的<strong>python语句</strong></li><li><code>exec(print(&quot;hello world&quot;))</code></li><li>This function supports dynamic execution of Python code. object must be either a string or a code object</li><li>The source may be a string representing one or more Python statements</li><li><strong>处理字符串形式的python语句</strong></li><li><strong>将文本当作语句执行</strong></li><li>exec() arg 1 must be a string, bytes or code object</li></ul></li></ol><h5 id="repr"><a href="#repr" class="headerlink" title="repr"></a>repr</h5><ul><li>Return a string containing a printable representation of an object.</li><li>For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a <strong>repr</strong>() method.</li><li><strong>返回一个包含可打印表示的字符串</strong></li><li>可以直接交给eval使用，但是输出的结果依然是repr()的参数 </li><li><strong>主要用来取得对象的规范字符串表示</strong>，反引号也可以完成相同的功能</li><li>大多数时候<code>eval(repr(object)) == object</code>  <ul><li>repr 加了一层引号</li><li>eval 去掉一层引号</li></ul></li><li>使用<strong>repr</strong>方法控制repr的返回内容</li><li><img src="/2019/09/23/Python字符串详解/10ed7d8f.png" alt="repr和str"></li></ul><h4 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h4><h5 id="字符串的三种风格"><a href="#字符串的三种风格" class="headerlink" title="字符串的三种风格"></a>字符串的三种风格</h5><ol><li>单引号<ul><li>一般用于字符</li></ul></li><li>双引号<ul><li>一般用于字符串</li></ul></li><li>三引号<ul><li>主要解决多行字符串的问题<h5 id="字符串的基础单位"><a href="#字符串的基础单位" class="headerlink" title="字符串的基础单位"></a>字符串的基础单位</h5></li></ul></li></ol><ul><li><strong>字符</strong> - 最小的字符单位</li><li>unicode字符<ul><li>字母，符号(单的)，汉字</li></ul></li></ul><h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><ul><li>字符在Python的定义的是<code>bytes</code>，也就是<strong>字节流</strong>，包含多个字符</li><li>python中定义字符使用<code>b&#39;&#39;</code></li><li>或者使用 str.encode()</li><li>bytes can only contain ASCII literal characters</li><li>简单的字母</li></ul><h5 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h5><ul><li>字符串属于序列，可以<strong>使用切片操作</strong>，索引从0开始</li><li><strong>正向索引和负向索引可以混合使用</strong></li></ul><h5 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h5><ul><li>字符串<strong>不支持元素赋值</strong></li><li>‘str’ object does not support item assignment</li><li>字符串是不可变数据类型</li><li><strong>可以对字符串赋值为新的常量字符串</strong></li><li><strong>字符串除非重新赋值，否则字符串不会改变</strong></li></ul><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><blockquote><p>采用某些方式暂时取消该字符本来的含义<br>python中使用<code>\+字符</code>方式表示</p><ul><li><img src="/2019/09/23/Python字符串详解/6cffef75.png" alt="Python常见的转义字符"></li><li>作用<ol><li><strong>表示不可打印字符</strong><ul><li>\b \t \a</li><li>退格 tab 蜂鸣</li></ul></li><li>解决字符串中的<code>\t</code>等<strong>引起的错误</strong>–&gt; ‘\t’ </li></ol></li><li>最常用于目录 <code>\\</code> 表示<code>\</code>,而不是<strong>转义符号</strong><ul><li>主要用于windows系统中，windows系统中<code>\</code>用于目录分隔符</li></ul></li></ul></blockquote><h5 id="字符串常见运算符"><a href="#字符串常见运算符" class="headerlink" title="字符串常见运算符"></a>字符串常见运算符</h5><ol><li>+<ul><li>字符串的<strong>拼接</strong></li><li>两边只能是str，不能出现int</li><li>TypeError: can only concatenate str (not “int”) to str</li></ul></li><li><ul><li><ul><li>字符串的<strong>乘法</strong></li><li>序列的<em>乘法</em></li><li><strong>只能和整数相乘</strong></li><li>TypeError: can’t multiply sequence by non-int of type ‘str’</li><li>TypeError: can’t multiply sequence by non-int of type ‘float’</li></ul></li></ul></li><li>[]<ul><li>字符串的<strong>截取</strong></li><li>序列的<strong>截取</strong></li><li>str[n]</li><li>str[m,n,step]</li></ul></li><li>in / not in<ul><li>成员操作符</li><li>ch in str: ch是否存在于str中，返回True和False</li><li>ch 可以是<strong>单个字符，也可以是字符串</strong></li></ul></li></ol><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><ul><li><code>\n</code>和<code>\r\n</code> 都起到换行符</li><li>和<b>平台有关，一般可以兼容，效果是一样</b></li><li><table><thead><tr><th>\n</th><th>回车，光标在下一行</th></tr></thead><tbody><tr><td>\r</td><td>换行，光标在上一行</td></tr></tbody></table></li></ul><h4 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h4><ul><li><p><code>format()</code></p></li><li><p>Convert a value to a “formatted” representation, as controlled by format_spec. </p></li><li><p>The interpretation of format_spec will depend on the type of the value<br>argument</p></li><li><p>“Format specifications” are used within replacement fields contained<br>within a format string to define how individual values are presented</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;  # 填充字符</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;   # 对其角度</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;     # 标志，仅对数字有效</span><br><span class="line">width           ::=  digit+   # 宽度</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;   # 数字千分位</span><br><span class="line">precision       ::=  digit+   # 精度</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;  #类型a</span><br></pre></td></tr></table></figure></li><li><p><img src="/2019/09/23/Python字符串详解/49d4d88f.png" alt="类型1"></p></li><li><p><img src="/2019/09/23/Python字符串详解/81291b59.png" alt="类型2"></p></li><li><p>用法 </p><ol><li>函数 <code>format(&quot;字符串&quot;,&quot;格式化表达式&quot;)</code></li><li>方法 <code>&quot;{}，{}，{}&quot;.format(字符串，字符串)</code></li></ol></li></ul><ol><li>函数<ul><li>参数：和格式字符串中的类型一致</li><li>函数 <strong>会将 数据 按照类型进行处理，转换成字符串</strong></li><li>ValueError: Unknown format code ‘f’ for object of type ‘str’</li></ul></li><li>格式化字符串<ul><li>“%s”.% num  一个完整的字符串 <strong>%替换内容</strong></li><li><img src="/2019/09/23/Python字符串详解/52c7c96e.png" alt="精细参数"></li><li><code>%[填充符号][对齐][宽度][,千分位][.精度][类型]</code><ul><li>填充：默认空格</li><li>对齐: &lt; &gt; =</li></ul></li></ul></li><li>特殊表现</li></ol><ul><li><code>%%</code>:<strong>特殊的转义字符</strong>，表示输出一个<code>%</code></li><li><a href="8.字符串格式化表达.py">%转移字符</a></li></ul><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><ul><li>Python2中，<strong>普通的字符是以8位的ASCII码进行存储的，而Unicode字符串则存储为16为Unicode字符串</strong>,使用的语法是在字符串前加<code>u</code></li><li>python3中, <strong>所有的字符串都是Unicode字符串</strong></li><li>ASCII格式没有中文，可以编译<ul><li>但是存储中文的话，不能通过编译，必须使用<code>utf-8</code></li></ul></li><li>utf-8和ASCII比较<ul><li>同等条件下，空间占用较大</li><li>utf-8  可以编译中文</li><li><strong>python3中默认字符集Unicode，默认编码格式utf-8</strong></li></ul></li></ul><h5 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h5><ul><li>Both string and bytes literals may optionally be prefixed with a letter ‘r’ or ‘R’; such strings are called raw strings and treat backslashes as literal characters. </li><li>As a result, in string literals, ‘\U’ and ‘\u’ escapes in raw strings are not treated specially.</li><li>格式： <code>r&quot;字符串&quot;</code><ul><li>但是如果字符串本身带着<code>&quot;</code>,r 不适用</li></ul></li></ul><h5 id="查看字符串帮助"><a href="#查看字符串帮助" class="headerlink" title="查看字符串帮助"></a>查看字符串帮助</h5><ul><li><p>dir(‘’)</p><ul><li>Without arguments, return the list of names in the current local scope. </li><li>With an argument, attempt to return <b>a list of valid attributes for that object.</b></li><li>If the object does not provide <strong>dir</strong>(), the function tries its best to gather information from the object’s <b><strong>dict</strong> attribute</b>, if defined, and from its type object. </li><li>The resulting list is not necessarily complete, and may be inaccurate when the object has a custom <strong>getattr</strong>(). </li><li><strong>输出包含对象所属类型的属性和方法的列表</strong></li><li>获取对象有<strong>哪些属性和方法</strong></li></ul></li><li><p>help()</p><ul><li>查看对象的<strong>具体属性的文档</strong></li><li>第一种风格：<code>”“.find</code> 使用<code>&lt;对象&gt;.&lt;方法/属性&gt;</code> 查看</li><li>第二种风格：<code>str.find</code> 使用<code>&lt;类型&gt;.&lt;方法/属性&gt;</code> 查看 </li></ul></li></ul><h5 id="字符串的方法和函数"><a href="#字符串的方法和函数" class="headerlink" title="字符串的方法和函数"></a>字符串的方法和函数</h5><ul><li><strong>字符串的方法和函数数量比较多</strong></li><li>字符串是<strong>不可变数据类型</strong>，他的方法都<strong>返回一个新的字符串</strong>，<strong>不会对原始的字符串产生影响</strong></li><li>常用方法和函数</li></ul><ol><li><p>str.capitalize() </p><ul><li>Return <strong>a copy of the string with its first character capitalized and the rest lowercased.</strong></li><li>返回一个<strong>首字母大写，其余字母小写的副本</strong></li><li><strong>只对英文字符起作用</strong></li></ul></li><li><p>str.center(width[, fillchar]) </p><ul><li>Return centered in a string of length width.</li><li>Padding is done using the specified fillchar (default is an ASCII space). </li><li>The original string is returned if width is less than or equal to len(s).</li><li><strong>返回一个长度是width的字符串，其中原本字符串居中，两边用fillchar填充</strong></li><li>fillchar 默认 <strong>空格</strong></li></ul></li><li><p>str.count(sub[, start[, end]]) </p><ul><li>Return the number of non-overlapping occurrences of substring sub in the range [start, end]. </li><li>Optional arguments start and end are interpreted as in slice notation.</li><li><strong>返回索引范围内的非重叠出现次数</strong></li><li><strong>切片默认是整个字符串</strong>1</li></ul></li><li><p>str.endswith(suffix[, start[, end]]) </p><ul><li>Return True if the string ends with <strong>the specified suffix</strong>, otherwise return False. </li><li>suffix can also be <strong>a tuple of suffixes to look for</strong>. </li><li>With optional start, test beginning at that position. With optional end, stop comparing at that position.</li><li>判断字符串是否是stuffix <strong>后缀</strong> 结尾</li><li><strong>后缀可以是个元组</strong></li><li><strong>本质上是判断以什么字符结尾</strong><ul><li>可以用作判断后缀</li></ul></li><li>相反的str.startswith(prefix[, start[, end]]) </li></ul></li><li><p>str.expandtabs(tabsize=8) </p><ul><li>返回一个副本，<strong>字符串中的tab键由指定的空格数替换</strong></li><li>默认的是8</li><li>Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size.</li></ul></li><li><p>str.find(sub[, start[, end]]) </p><ul><li>Return the <strong>lowest index</strong> in the string where substring sub is found within the slice s[start:end].</li><li>Optional arguments start and end are interpreted as in slice notation. Return <strong>-1</strong> if sub is not found.</li><li>查找函数，找不到返回 -1</li><li>注意<ul><li><strong>只是在需要知道sub在那个位置时，才使用find</strong></li><li>如果需要判断是否在字符串中，需要使用in</li></ul></li><li>rfind()<ul><li>Return the <strong>highest index</strong> in the string where substring sub is found,</li><li><strong>sub重复出现，返回最高的索引</strong></li></ul></li></ul></li><li><p>index(sub[, start[, end]]) </p><ul><li>Like find(), but raise <code>ValueError</code> when the substring is not found.</li><li>和find相似</li><li>但是当sub不存在的时候，报ValueError</li><li>rindex() 和 rfind() 类似</li></ul></li><li><p>判断函数</p><ul><li><p><strong>判断字符串是不是数字的，纯字符的等</strong></p></li><li><p><img src="/2019/09/23/Python字符串详解/76f39d58.png" alt="常见判断函数"></p></li><li><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>isalnum</td><td>一个<strong>字母数字</strong>字符串，不能出现汉字和其他符号</td></tr><tr><td>isalpha</td><td>一个<strong>字母</strong>字符串，所有字符全部是字母，不能包含数字</td></tr><tr><td>isascii</td><td>有acsii码组成的字符串，其中””空字符串也属于</td></tr><tr><td>isdecimal</td><td>十进制字符串</td></tr><tr><td>isdigit</td><td>数字字符串,和上面稍微不一样</td></tr><tr><td>isnumeric</td><td>所有字符都是数字</td></tr><tr><td>islower</td><td>判断小写</td></tr><tr><td>isspace</td><td><strong>空格字符串</strong>，不是空字符串；包含·’\t’,’\n’,’\r’等空白字符</td></tr><tr><td>istitle</td><td>标题字符串，第一个大写，其他字符小写,注意含有空格的情况下，<strong>每个空格后第一个字母都要大写</strong></td></tr></tbody></table></li><li><p>注意：<strong>判断字符串中字符的情况是在非空字符串的条件下</strong></p></li><li><p>注意：<strong>汉字没有大小写之分</strong></p><ul><li>当字符串中全部是汉字时，isupper和islower结果是False</li><li>当字符串中包含其他字符和汉字时，<strong>isupper和islower会忽略汉字进行判断</strong></li></ul></li></ul></li><li><p>可打印字符和空字符</p><ul><li>isspace()<ul><li><strong>字符串中只有空格字符且至少有一个字符</strong></li><li>空白字符：是Unicode数据库中定义的’others’和’Separator’字符</li></ul></li><li>isprintale()<ul><li><strong>字符串中所有字符是可打印的或则空字符串</strong></li><li>Nonprintable characters are those characters defined in the Unicode character database as “Other” or “Separator”, excepting the ASCII space (0x20) which is considered printable.</li><li>0x20 是<strong>空格，是可以打印的</strong></li><li><strong>在上下文环境中，repr()转移的字符是不可打印字符</strong></li><li><img src="/2019/09/23/Python字符串详解/056b29ea.png" alt="上下文环境的repr"></li></ul></li></ul></li><li><p>str.join(iterable) </p><ul><li>Return a string which is the concatenation of the strings in iterable</li><li>The separator between elements is the string providing this method.</li><li><strong>参数是可迭代的对象</strong></li><li><strong>分隔符参数提供了该方法</strong> </li><li>按照指定的字符作为<strong>间隔符</strong>和<strong>可迭代对象</strong>生成新的字符串</li></ul></li><li><p>str.rjust(width[, fillchar]) </p><ul><li>类似center，但是是<strong>左边填充</strong></li><li>ljust： <strong>右边填充</strong></li></ul></li><li><p>str.lower() / upper()</p><ul><li>对 中文字符无意义</li><li>字符全部转换成大写，或者小写</li><li>常用 <strong>忽略大小写</strong></li></ul></li><li><p>str.replace(old, new[, count]) </p><ul><li>如果没有count参数，则替换所有的old字符</li><li>如果有count参数，<strong>根据count的数量从前到后进行替换</strong></li></ul></li><li><p>str.strip([chars]) </p><ul><li><strong>返回一个已经删除了最前面或者最后面chars字符的字符串</strong></li><li>chars =None或者省略时，<strong>删除空格</strong></li><li>chars：<strong>要删除的字符集，不是前缀或后缀，是所有值的组合都被剥离</strong></li><li>The chars argument is not a prefix or suffix; rather, <strong>all combinations of its values are stripped</strong></li><li>有两个形同的 rstrip()和lstrip() 表示从右边或左边删除</li><li><strong>删除字符集中字符直到不属于集合中的字符截至，不能间断</strong></li></ul></li><li><p>str.zfill(width) </p><ul><li>Return a copy of the string left filled with ASCII ‘0’ digits to make a string of length width.</li><li>A leading sign prefix (‘+’/‘-‘) is handled by inserting the padding after the sign character rather than before</li><li><strong>在左边填充0达到指定的长度</strong></li><li>带有符号的对象，在<strong>符号和数值中间填充</strong></li></ul></li><li><p>str.swapcase() </p><ul><li>Return a copy of the string with uppercase characters converted to lowercase and vice versa.</li><li><strong>修改字符串中字符的大小写，大写转小写，小写转大写，字符级别的</strong></li></ul></li><li><p>str.translate(table) </p><ul><li>Return a copy of the string in <strong>which each character</strong> has been mapped through <strong>the given translation table.</strong></li><li><strong>每个元素对照翻译表</strong></li><li>The table must be an object that implements indexing via <strong>getitem</strong>(), typically a mapping or sequence.</li><li>翻译表必须可以通过<strong>gititem</strong>()，一般是<strong>映射和序列</strong></li><li>You can use str.maketrans() to create a translation map from character-to-character mappings in different formats.</li><li><strong>使用str,maketrans()创建字符-字符的映射</strong></li></ul></li><li><p>static str.maketrans(x[, y[, z]]) </p><ul><li>是一个静态方法</li><li>用于创建str.translate()的<strong>转换表</strong></li><li><strong>一个参数的话，必须是字典</strong>，将Unicode序列，字符映射到另一个Unicode序列</li><li><strong>两个参数，必须是两个长度相等的字符串</strong></li><li><strong>第三个参数表示指向None，翻译的时候也是None，表示的是省略</strong><h5 id="字符串的切割"><a href="#字符串的切割" class="headerlink" title="字符串的切割"></a>字符串的切割</h5></li></ul></li><li><p>str.split(sep=None, maxsplit=-1) </p><ul><li><strong>将字符串按照sep进行分割，返回包含字符的列表</strong></li><li>sep 默认是 空格，<ul><li>但是<strong>字符串前面或后面的空格不参与</strong> leading or trailing whitespace,在sep为None的情况下</li><li><strong>字符串中间的连续空格被当作一个处理</strong></li><li><strong>如果sep是其他字符，字符串中的空格也会被处理成一个元素</strong><code>&quot;&quot;</code><ul><li><strong>而且不会在换行的地方产生新的元素</strong>，<code>a\nv</code></li></ul></li></ul></li><li>maxsplit 限制切割次数<ul><li>默认 -1：即尽可能的分割</li><li>列表最大有 maxsplit+1个元素</li></ul></li></ul></li><li><p>str.splitlines([keepends]) </p><ul><li>按行切割</li><li>返回包含行的列表</li><li><code>keepends</code> 保留边界字符，也就是换行符，默认<strong>不保留</strong></li><li><img src="/2019/09/23/Python字符串详解/e3ba965f.png" alt="换行符"></li></ul></li></ol><h5 id="字符串中三种数字的对比"><a href="#字符串中三种数字的对比" class="headerlink" title="字符串中三种数字的对比"></a>字符串中三种数字的对比</h5><ul><li><p>在unicode定义中，一下所有的都是数字</p></li><li><p><img src="/2019/09/23/Python字符串详解/ff4bf9e4.png" alt="wiki定义"></p></li><li><p><a href="14.数字字符串的区别.py">示例</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">⅐   ⅑   ⅒   ⅓   ⅔   ⅕   ⅖   ⅗   ⅘   ⅙   ⅚   ⅛   ⅜   ⅝   ⅞   ⅟</span><br><span class="line">Ⅰ   Ⅱ   Ⅲ   Ⅳ   Ⅴ   Ⅵ   Ⅶ   Ⅷ   Ⅸ   Ⅹ   Ⅺ   Ⅻ   Ⅼ   Ⅽ   Ⅾ   Ⅿ</span><br><span class="line">ⅰ   ⅱ   ⅲ   ⅳ   ⅴ   ⅵ   ⅶ   ⅷ   ⅸ   ⅹ   ⅺ   ⅻ   ⅼ   ⅽ   ⅾ   ⅿ</span><br><span class="line">ↀ   ↁ   ↂ   Ↄ   ↄ   ↅ   ↆ   ↇ   ↈ   ↉   ↊   ↋</span><br></pre></td></tr></table></figure></li><li><p>isdecimal</p><ul><li><img src="/2019/09/23/Python字符串详解/d0a2e3f0.png" alt=" U+0660, ARABIC-INDIC DIGIT ZERO"></li><li><strong>十进制数字，也就是阿拉伯数字，包含全角和半角</strong></li><li>Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. </li><li>Formally a decimal character is a character in the Unicode General Category “Nd”.</li></ul></li><li><p>isdigit</p><ul><li>Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. </li><li>This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers.</li><li>Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.</li><li><strong>包含十进制字符和一些特殊处理的数字，不一定基于十进制数字</strong></li><li>经过特殊处理的如 ①，¹ 等</li></ul></li><li><p>isnumberic</p><ul><li><img src="/2019/09/23/Python字符串详解/48490a2e.png" alt=" U+2155, VULGAR FRACTION ONE FIFTH"></li><li>Numeric characters include digit characters, and all characters that have the Unicode numeric value property,</li><li>e.g. U+2155, VULGAR FRACTION ONE FIFTH. </li><li>Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.</li><li><strong>包含digit，和所有具有Unicode数值属性的字符</strong></li><li>具有Unicode数值属性的所有字符<h5 id="字符串的编码"><a href="#字符串的编码" class="headerlink" title="字符串的编码"></a>字符串的编码</h5></li></ul></li><li><p>Return an <strong>encoded version</strong> of the string <strong>as a bytes object</strong>. </p></li><li><p>Default encoding is ‘utf-8’. </p></li><li><p>errors may be given to set a different <strong>error handling scheme</strong>. The default for errors is ‘strict’, meaning that encoding errors raise a UnicodeError</p></li><li><p><strong>对字符串按照提供的编码格式进行编码，转成bytes</strong></p><h6 id="error-handling"><a href="#error-handling" class="headerlink" title="error handling"></a>error handling</h6></li><li><p><img src="/2019/09/23/Python字符串详解/5c181c38.png" alt="error_handling"></p></li></ul><h4 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h4><ul><li>Bytes objects are immutable sequences of single bytes.</li><li><strong>字节对象是单个字符的不可变序列</strong></li><li><strong>单个字符-【0，255】</strong></li><li><strong>字节</strong></li><li>一个byte = 8个bit = 2<strong>8 = **256</strong> </li><li><strong>ASCII 第一位表示正负标识，其余7为表示字符</strong></li><li>定义：<ul><li>bytes() <strong>转换成二进制表示</strong><ul><li><strong>包含汉字的必须使用bytes转换成二进制</strong></li><li>英文，数字 都转换成了 二进制</li><li>使用十六进制表示</li></ul></li><li>b<code>1</code>:表示字符串的二进制<ul><li><strong>字符串可以使用简单的ASCII表示</strong></li><li><img src="/2019/09/23/Python字符串详解/4f23c1f0.png" alt="是汉字的情况"></li></ul></li><li>在Python中<ul><li>字符串编码encode后<ul><li>中文 –》 十六进制</li><li>英文和数字(&lt;255): —&gt; b’英文/数字’</li></ul></li><li>解码<ul><li>b’0x*****’ —&gt;  中文</li><li>b’1’ —-》 ‘1’</li></ul></li></ul></li></ul></li><li><code>class bytes([source[, encoding[, errors]]])</code><ul><li>Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a b prefix is added:</li><li>字节和字符串的语法基本相同，不过前面添加了<code>b</code></li><li>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). </li><li>Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</li><li>字节只使用127个ASCII字符<blockquote><p>In addition to the literal forms, bytes objects can be created in a number of other ways:<br><strong>A zero-filled bytes object of a specified length</strong>: bytes(10)<br><strong>From an iterable of integers</strong>: bytes(range(20))<br>Copying existing binary data via the buffer protocol: bytes(obj)</p></blockquote></li><li><img src="/2019/09/23/Python字符串详解/fdb26710.png" alt="bytes类"></li><li><img src="/2019/09/23/Python字符串详解/3a987dab.png" alt="bytes的初始化"></li><li><a href="11.字符串的编码.py">bytes的使用</a><h5 id="utf-8-与-汉字"><a href="#utf-8-与-汉字" class="headerlink" title="utf-8 与 汉字"></a>utf-8 与 汉字</h5></li></ul></li><li>utf-8 使用三个字符表示汉字，其中1个表示结束，1个表示开始</li><li>gbk 使用两个字符表示汉字，没有结束符</li><li>不同的编码，对汉字表示不一致，所有解码和编码的编码格式必须一致，否则解码错误<h6 id="文件存储在硬盘和文件中存储的是二进制方式"><a href="#文件存储在硬盘和文件中存储的是二进制方式" class="headerlink" title="文件存储在硬盘和文件中存储的是二进制方式"></a>文件存储在硬盘和文件中存储的是二进制方式</h6><h6 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h6></li><li>str 字符串 编码成 二进制 <code>encode()</code></li><li>bytes 字节 解码 —》 字符串 <code>decode()</code></li><li>注意：<strong>编码格式一致</strong>,否则<strong>代码错误或者乱码</strong><ul><li><strong>主要是对 中文</strong></li><li><strong>英文的编码在任何字符集中都是一致的</strong><ul><li>字符集是在ASCII码的基础上发展的<br><img src="/2019/09/23/Python字符串详解/25935f82.png" alt="decode"><br><img src="/2019/09/23/Python字符串详解/dc268b51.png" alt="encode"></li></ul></li></ul></li><li>应用：<ul><li>爬虫抓取网页</li></ul></li></ul><h6 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h6><ul><li>Bytes() 的错误处理 机制  error handling</li><li>ignore  解码失败的情况下，强行解码</li><li>strics  默认的，报错 <code>UnicodeDecodeError</code></li></ul><h5 id="字符串的模板"><a href="#字符串的模板" class="headerlink" title="字符串的模板"></a>字符串的模板</h5><ul><li>字符串模板，做好模板，<strong>使用<code>$变量</code>等待传入数据</strong></li><li><strong>提供了更为简单的字符串替换</strong></li><li>Template String 使用了基于<strong>$变量</strong>的替换<ul><li>使用单个的<code>$</code></li><li><code>${identifier}</code>或则和<code>$identifier</code>:同样的作用，主要是区分占位符</li></ul></li><li>class string.Template(template) <ul><li>单个参数，即构造字符串</li></ul><ol><li>substitute(mapping, **kwds) <ul><li>执行模板替换，返回一个新的字符串</li><li>mapping：类似字典的对象，<strong>键值和模板占位符匹配</strong></li><li>也可以提供<strong>关键字参数</strong></li></ul></li><li>safe_substitute(mapping, **kwds) <ul><li>同上一个，稍微优化</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串详解&quot;&gt;&lt;a href=&quot;#字符串详解&quot; class=&quot;headerlink&quot; title=&quot;字符串详解&quot;&gt;&lt;/a&gt;字符串详解&lt;/h3&gt;&lt;h4 id=&quot;eval-和-evec&quot;&gt;&lt;a href=&quot;#eval-和-evec&quot; class=&quot;headerlink&quot; title=&quot;eval 和 evec&quot;&gt;&lt;/a&gt;eval 和 evec&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;eval：&lt;ul&gt;
&lt;li&gt;eval 语句用来计算存储在字符串中的&lt;strong&gt;有效表达式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;内置函数&lt;/li&gt;
&lt;li&gt;可以转化为实数,&lt;strong&gt;只能处理字符串形式的表达式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;常见的使用：&lt;code&gt;num = eval(input(&amp;quot;输入数据:&amp;quot;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The expression argument is parsed and evaluated as a Python expression &lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval(&amp;quot;2+2&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数是 “字符串”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;eval() arg 1 must be a string, bytes or code object&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将文本当作表达式使用&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础数据类型</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/23/Python基础数据类型/</id>
    <published>2019-09-23T07:17:46.000Z</published>
    <updated>2019-09-23T07:25:11.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><strong>零个或多个字符的有序集合</strong></li><li>属于 <strong>序列</strong><ul><li>可以进行序列操作，如[]</li><li>索引从0开始</li><li>for循环遍历<a id="more"></a>    <h5 id="enumrate-函数"><a href="#enumrate-函数" class="headerlink" title="enumrate() 函数"></a>enumrate() 函数</h5></li></ul></li><li><code>enumerate(iterable, start=0)</code> </li><li>Return an enumerate object. </li><li>iterable must be a sequence, an iterator, or some other object which supports iteration. </li><li>The <strong>next</strong>() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.</li><li>返回一个<strong>枚举对象</strong>，有元组组成</li><li>元组的元素是 <strong>可迭代对象的值和索引</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span><span class="params">(sequence, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h5><ol><li>字符串的截取<ul><li>str[start:stop:step]</li><li>不包含stop</li><li>step 默认1</li><li>[0:0:-1] <strong>反序</strong></li></ul></li><li>字符串索引<ul><li>正向索引：<strong>从0开始，从左到右</strong></li><li>反向索引：<strong>从-1开始，从右到左</strong></li></ul></li></ol><ul><li>字符串操作符<ul><li><ul><li>字符串拼接</li></ul></li><li><ul><li>字符串重复  <strong>后面接数字</strong></li></ul></li><li>in 成员元素符</li></ul></li><li>字符串的循环<ol><li>in操作符，使用字符遍历</li><li>索引，使用索引遍历</li></ol><ul><li>主要用途：<strong>加密和解密</strong></li></ul></li></ul><h4 id="字符串本质"><a href="#字符串本质" class="headerlink" title="字符串本质"></a>字符串本质</h4><ul><li><strong>字符串是零个或多个字符和有序集合</strong></li><li><strong>字符串内部是不可更改的</strong><ul><li><strong>没有对字符串中单个字符赋值的操作</strong></li><li>TypeError: ‘str’ object does not support item assignment</li><li>字符串是一个整体</li></ul></li><li><strong>字符串属于不可变数据类型</strong></li><li>可以赋值，但是是<strong>指向 新的字符串</strong></li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>列表</li><li>一组元素的集合，使用[]包括，且元素之间使用<code>,</code>隔开</li><li>属于 <strong>序列</strong></li></ul><h5 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h5><ol><li><p>for循环遍历</p><ol><li>元素循环  for ch  in list</li><li>索引索引 range(len(list) - 1)</li></ol></li><li><p>len()</p><ul><li>统计list的元组个数</li></ul></li><li><p>append()</p><ul><li>列表添加元素，在末端位置</li><li><strong>添加的是一个元素</strong><ul><li>参数是列表的话，当作一个元素</li></ul></li><li>和 + 区别</li></ul></li><li><p>1 extend()</p><ul><li>列表末尾添加元素</li><li>参数是可迭代对象，添加元素</li><li><a href="4.列表的基本操作.py">extend 和 append</a></li></ul></li><li><p>index()</p><ul><li>返回元素的索引位置，</li><li>如果没有的话，报错 <code>ValueError: -3 is not in list</code></li></ul></li><li><p>切片</p><ul><li>[::-1]  反序</li><li><strong>需要赋值给其他变量</strong></li><li>和 字符串一致</li></ul></li><li><ul><li><ul><li>列表的拼接</li><li><strong>列表各个元素</strong>的拼接</li></ul></li></ul></li><li><p>*</p><ul><li>复制两次</li><li>使用的是<strong>列表的元素</strong></li></ul></li></ol><h4 id="列表的本质"><a href="#列表的本质" class="headerlink" title="列表的本质"></a>列表的本质</h4><ul><li><strong>列表属于可变数据类型</strong></li><li><strong>列表的元素可以变化</strong></li><li><strong>元素改变之后列表的地址没有变化</strong><h5 id="list-容量"><a href="#list-容量" class="headerlink" title="list 容量"></a>list 容量</h5></li><li><strong>可以用到内存的尽头</strong></li></ul><h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h4><ul><li>不被修改的list，用<code>()</code>定义</li><li>属于<strong>序列</strong></li><li>循环方式一致<ul><li>循环的作用<strong>只能输出打印</strong></li></ul></li></ul><h5 id="不可变数据类型"><a href="#不可变数据类型" class="headerlink" title="不可变数据类型"></a>不可变数据类型</h5><ul><li><strong>元组的元素不能修改，属于常量</strong></li></ul><h5 id="元组的特例"><a href="#元组的特例" class="headerlink" title="元组的特例"></a>元组的特例</h5><ul><li><strong>创建单元素元组的时候，必须在元素后面加逗号</strong></li><li>否则的话，创建的是元素对象，而不是元组</li><li><a href="7.元组的特点.py">单元素</a></li></ul><h4 id="set-集合操作"><a href="#set-集合操作" class="headerlink" title="set 集合操作"></a>set 集合操作</h4><ul><li><p><strong>无序的不重合元素序列</strong></p></li><li><p>使用set()或者<code>{}</code>创建集合</p></li><li><p><strong>set不支持序列index操作，没有下标</strong></p></li><li><p>但是<strong>创建一个空集合必须用 <code>set()</code>而不是 <code>{ }</code></strong>，因为 { } 是用来创建一个空字典</p></li><li><p><code>frozenset()</code> 返回一个<strong>冻结的集合</strong>，<strong>冻结后集合不能再添加或删除任何元素</strong></p></li><li><p>循环–<strong>元素循环</strong></p></li><li><p>常见用途</p><ul><li>成员关系测试<ul><li>in</li><li>not in </li></ul></li><li>删除重复元素<ul><li><ul><li>差集</li></ul></li><li>| 并集</li><li>&amp; 交集</li><li>^ 不同时存在的元素</li></ul></li></ul></li><li><p>set无序排序且不重复，是可变的，有add（），remove（）等方法。既然是可变的，所以它不存在哈希值。基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交集), difference(差集)和sysmmetric difference(对称差集)等数学运算.<br>sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, 或其它类序列的操作。<br>frozenset是冻结的集合，它是不可变的，存在哈希值，好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法。</p></li></ul><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul><li><p>不重复的键值对的无序集合</p><ul><li><strong>会覆盖掉的</strong>   </li></ul></li><li><p><code>key:value</code> 模型，<strong>键值对之间用逗号隔开</strong></p></li><li><p>set的升级版</p></li><li><p>使用<code>{}</code>定义</p></li><li><p><strong>值可以取任何数据类型，但键必须是不可变的</strong></p></li><li><p><strong>key不能重复，value可以重复</strong></p><h5 id="字典的方法"><a href="#字典的方法" class="headerlink" title="字典的方法"></a>字典的方法</h5></li></ul><ol><li>items()<ul><li>返回(key,value)列表</li></ul></li><li>keys()<ul><li>返回keys列表</li></ul></li><li>values()<ul><li>返回values列表<h5 id="字典的循环"><a href="#字典的循环" class="headerlink" title="字典的循环"></a>字典的循环</h5></li></ul></li></ol><ul><li>for循环只能使用 元素遍历循环<ol><li>遍历 key  .keys()</li><li>遍历 value   .values()</li><li>遍历 键值对   .items()</li></ol></li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><ol><li>in</li><li>not in</li></ol><ul><li>对于list和tuple 是否存在</li><li>对于dict，<strong>判断键是否存在于字典中</strong></li></ul><h5 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h5><ul><li>在for循环中，in操作符表示<strong>遍历</strong></li></ul><h4 id="构造表达式"><a href="#构造表达式" class="headerlink" title="构造表达式"></a>构造表达式</h4><ul><li><code>mylist 变量 = [x 返回值或者元素 for x in range(10) 元素构造表达式  ]</code></li><li>列表构造表达式</li><li>字典构造表达式</li></ul><h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><ul><li><img src="/2019/09/23/Python基础数据类型/a27a0e2b.png" alt="数据类型转换函数"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础数据类型&quot;&gt;&lt;a href=&quot;#基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;基础数据类型&quot;&gt;&lt;/a&gt;基础数据类型&lt;/h3&gt;&lt;h4 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;零个或多个字符的有序集合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;属于 &lt;strong&gt;序列&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;可以进行序列操作，如[]&lt;/li&gt;
&lt;li&gt;索引从0开始&lt;/li&gt;
&lt;li&gt;for循环遍历&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/23/Python函数/</id>
    <published>2019-09-23T07:14:30.000Z</published>
    <updated>2019-09-23T07:17:04.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>将<strong>代码块**</strong>封装<strong>到一个</strong>def定义的函数名**中</li><li>def 关键字 用于定义函数名</li><li>之后使用函数名可以<strong>多次使用代码块</strong>，<strong>不需要重写代码块</strong></li><li>简化代码编写，<strong>代码块反复利用</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数体</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">函数名(实际参数列表)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><img src="/2019/09/23/Python函数/af01568b.png" alt="函数定义，调用"></li></ul><h5 id="函数抽象和逐步求精"><a href="#函数抽象和逐步求精" class="headerlink" title="函数抽象和逐步求精"></a>函数抽象和逐步求精</h5><ul><li>函数抽象：将<strong>函数的使用</strong>和<strong>函数的实现</strong>分开实现</li></ul><h5 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h5><ol><li>没有参数，没有返回值<ul><li>参数列表为空</li><li>没有 return语句</li><li>一般用于打印 <code>字符串</code></li></ul></li><li>有参数，没有返回值<ul><li>参数需要传入</li><li>没有 return 语句</li><li>常用于 打印 <code>变量内容</code></li></ul></li><li>没有参数，有返回值<ul><li>没有参数传入</li><li>有 return 语句</li><li>常用于 返回固定的值或者随机数</li><li>需要变量接受返回值</li></ul></li><li>有参数，有返回值<ul><li>常见的</li><li>有参数传入，有返回值</li></ul></li></ol><h4 id="函数的执行顺序"><a href="#函数的执行顺序" class="headerlink" title="函数的执行顺序"></a>函数的执行顺序</h4><ul><li>顺序执行</li><li>依次执行完成，再执行下一个<h5 id="函数的复合调用过程"><a href="#函数的复合调用过程" class="headerlink" title="函数的复合调用过程"></a>函数的复合调用过程</h5></li><li>瀑布执行</li><li>遇到函数调用，就执行函数，<strong>当执行到return或者函数体完成时返回到主函数中</strong><ul><li>继续主函数的执行</li></ul></li><li><strong>函数调用必须等待函数返回之后，才能执行下一步</strong></li><li><img src="/2019/09/23/Python函数/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="函数调用过程">   </li></ul><h4 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h4><ul><li>函数的本质是一个<strong>地址</strong></li><li><strong>函数名是变量，存储一段代码的地址</strong></li><li>所以可以将函数名赋值给另一个变量</li><li>但是函数后面接参数的时候，赋值给另一个变量，是将函数的返回数据赋值给变量</li><li>直接<code>print(函数名)</code>: 可以看到<strong>函数名的具体内容</strong></li><li><strong>修改地址可以实现不同的行为</strong></li></ul><h4 id="函数变量的用途"><a href="#函数变量的用途" class="headerlink" title="函数变量的用途"></a>函数变量的用途</h4><ul><li>接口：函数的<strong>对外</strong>，<strong>变量列表</strong>，不变</li><li>业务需求：是常常变化的， </li><li><strong>业务需求发生变化</strong>，但是<strong>代码内容不变</strong></li></ul><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li><strong>函数当作另一个函数的参数</strong></li><li>是修改其他函数的功能的函数</li><li>封装一个函数，并且用这样或者那样的方式来修改它的行为</li><li>用于拓展原来函数功能的一种函数，目的是在不改变原函数名(或类名)的情况下，给函数增加新的功能。 这个函数的特殊之处在于它的<strong>返回值也是一个函数</strong>，这个函数是内嵌“原“”函数的函数。</li></ul><h5 id="None"><a href="#None" class="headerlink" title="None"></a>None</h5><ul><li><strong>函数如果没有明确返回值，函数默认返回None</strong></li></ul><ol><li>没有return语句，默认返回None<ul><li>如果print函数或者有变量接受，结果是None</li></ul></li><li>有return语句，但是return 后面没有任何数据，返回None </li></ol><h4 id="实际参数-和-形式参数"><a href="#实际参数-和-形式参数" class="headerlink" title="实际参数 和 形式参数"></a>实际参数 和 形式参数</h4><ul><li>实参： <strong>函数调用时传入的参数</strong></li><li>形参： <strong>函数定义时参数列表中的参数，也就是在函数体中没有赋值直接使用的参数</strong></li><li>调用函数时，必须正确传递参数<ul><li>保持 <strong>实参与形参一一对应</strong></li></ul></li></ul><h5 id="默认参数，位置参数-和-关键字参数"><a href="#默认参数，位置参数-和-关键字参数" class="headerlink" title="默认参数，位置参数 和 关键字参数"></a>默认参数，位置参数 和 关键字参数</h5><ul><li>默认参数：函数定义时，<strong>在参数列表中已经赋值</strong><ul><li>当函数调用时，没有传入数值，使用默认参数</li><li>当函数调用时，传入了数值，使用传入的数值</li></ul></li><li>位置参数：函数调用传入实参，和形参<strong>按照位置一一对应</strong><ul><li>从左向右，依次填充</li></ul></li><li>关键字参数: 函数调用时，使用<code>形参=实参</code>的方式传递数据<ul><li>也称为：名称参数</li><li><strong>顺序可以混乱</strong></li><li><strong>位置参数可以和名称参数混用</strong><ul><li>必须是 先位置参数，再名称参数</li><li>print(“zhaolong”,end=” “)</li></ul></li></ul></li></ul><h5 id="参数副本机制（不可变数据类型）"><a href="#参数副本机制（不可变数据类型）" class="headerlink" title="参数副本机制（不可变数据类型）"></a>参数副本机制（不可变数据类型）</h5><ul><li>传递参数时，<strong>把实参拷贝给形参，把地址传递给形参</strong><ul><li>可变数据类型：列表，字典，元组<ul><li>会改变原来的值</li></ul></li><li>不可变数据类型：数值，字符串 <ul><li>不会改变原来的值</li></ul></li></ul></li></ul><h5 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h5><ul><li>return x,y,z… </li><li>函数返回多个参数，<strong>以元组的形式返回</strong></li><li>需要<strong>使用对应的变量</strong>接受返回数据</li></ul><h5 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h5><ul><li><strong>全局变量</strong>：函数外部定义的, 作用范围<strong>在程序内部</strong></li><li><strong>局部变量</strong>：函数内部定义的，作用在函数内部</li><li>函数内部的变量会首先查询局部变量，如果没有的话，才会使用同名的全局变量</li></ul><h6 id="引用全局变量-global"><a href="#引用全局变量-global" class="headerlink" title="引用全局变量  global"></a>引用全局变量  global</h6><ul><li>在函数内部，引用全局变量</li><li>使用<code>global</code>关键字<strong>申明使用全局变量</strong><ul><li>在函数内部使用的变量是全局变量</li><li>对变量的操作就是对全局变量的操作</li></ul></li></ul><h5 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h5><ul><li>函数可以<strong>嵌套定义</strong></li><li>使用内层的函数<ul><li><strong>必须在外层函数中明确调用内层函数</strong></li><li><a href="19.函数的嵌套.py">函数嵌套</a></li></ul></li><li>同名变量<ul><li>内层会覆盖外层变量，不同的变量，不同的地址</li><li><code>nonlocal 变量</code>: 不新建新的变量，使用外层的局部变量</li></ul></li></ul><h5 id="nonlocal-用于嵌套函数中-使用外层的局部变量"><a href="#nonlocal-用于嵌套函数中-使用外层的局部变量" class="headerlink" title="nonlocal 用于嵌套函数中 使用外层的局部变量"></a>nonlocal 用于嵌套函数中 使用外层的局部变量</h5><ul><li><strong>内层函数使用外层函数的局部变量，使用<code>nonlocal</code>关键字</strong><ul><li><code>nonlocal 外层同名变量</code></li><li><strong>不新建本地变量，引用外层局部变量</strong></li></ul></li></ul><h5 id="函数的两种类型"><a href="#函数的两种类型" class="headerlink" title="函数的两种类型"></a>函数的两种类型</h5><ol><li>内置函数 builtin_function_method</li><li>自定义函数 function</li></ol><h5 id="函数的执行顺序-1"><a href="#函数的执行顺序-1" class="headerlink" title="函数的执行顺序"></a>函数的执行顺序</h5><ol><li>函数执行结束后，之后的代码才可以执行</li><li>自上而下，顺序执行</li></ol><h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><ul><li>return <strong>之后的语句不会再被执行</strong></li><li>return 表示函数<strong>到此结束</strong></li></ul><h5 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h5><ul><li><p>python3的新特性</p></li><li><p>lambda 关键字</p></li><li><p>lambda <strong>参数</strong>a,b: <strong>返回值</strong> a+b</p></li><li><p>不需要使用def</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class 'function'&gt;</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x0000023115C09288&gt;</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ol><li>lambda x:print(x):是一个匿名函数</li><li><strong>调用的时候需要给函数加（）</strong>，<strong>是一个整体</strong>，或则赋值给一个变量</li></ol><h5 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h5><ul><li>定义函数时，<strong>参数未知</strong></li><li>使用 <code>*num</code></li><li><code>*num</code>表示<strong>一个序列</strong>，<strong>传入多少数据，接受多个数据</strong></li><li><strong>函数调用时，参数之间使用逗号分隔</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;代码块**&lt;/strong&gt;封装&lt;strong&gt;到一个&lt;/strong&gt;def定义的函数名**中&lt;/li&gt;
&lt;li&gt;def 关键字 用于定义函数名&lt;/li&gt;
&lt;li&gt;之后使用函数名可以&lt;strong&gt;多次使用代码块&lt;/strong&gt;，&lt;strong&gt;不需要重写代码块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;简化代码编写，&lt;strong&gt;代码块反复利用&lt;/strong&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; 函数名&lt;span class=&quot;params&quot;&gt;(参数列表)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    函数体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#调用函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;函数名(实际参数列表)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python循环-for</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%BE%AA%E7%8E%AF-for/"/>
    <id>http://yoursite.com/2019/09/23/Python循环-for/</id>
    <published>2019-09-23T07:10:27.000Z</published>
    <updated>2019-09-23T07:12:52.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><ul><li>Python中的for循环通过一个<strong>序列</strong>中的<strong>每个值</strong>来进行<strong>迭代</strong></li><li>知道循环次数的</li><li><strong>计数器控制的循环</strong></li><li>不需要使用变量来控制循环</li><li>迭代环境，使用的是 <strong>可迭代的对象</strong><ul><li>列表</li><li>元组</li><li>字典</li><li>集合</li><li>字符串</li></ul></li><li>for循环<strong>处理速度稍微快点</strong><ul><li>主要是<strong>计数器参与运算的</strong>，不需要在循环体中再次编写</li></ul></li><li>for 循环的参数是<strong>正整数</strong>–计数器<a id="more"></a><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5></li><li><img src="/2019/09/23/Python循环-for/ff0ac7b8.png" alt="Range"></li><li>an immutable sequence of numbers 不可变的数字序列，用于For循环中</li><li>两种用法<ul><li><code>class range(stop)</code> </li><li><code>class range(start, stop[, step])</code></li></ul></li><li>函数的参数必须是<strong>整数</strong></li><li>省略step参数，则默认为1.省略start参数，默认为0.如果step为零，则引发<code>ValueError</code></li><li>不包含 stop</li><li>For a positive step, the contents of a range r are determined by the formula <code>r[i] = start + step*i where i &gt;= 0 and r[i] &lt; stop</code>.</li><li>For a negative step, the contents of the range are still determined by the formula <code>r[i] = start + step*i</code>, but the constraints are <code>i &gt;= 0 and r[i] &gt; stop</code>.</li><li>负指数，被解释为从正指数确定的序列末尾开始索引</li><li>负方向：表示的是从start开始，每次减去abs(step)的数值,而且 start &gt; stop</li><li>本质上，是从start开始到stop-1截至，按照step取值<ul><li>当step为正数，start&lt;stop,<code>做加法</code></li><li>当step为负数，start&gt;stop，<code>做减法</code></li><li>start != stop</li><li>i!= 0  </li></ul></li></ul><h5 id="else"><a href="#else" class="headerlink" title="else"></a>else</h5><ul><li>for - else：<ul><li><strong>恰好即将跳出循环</strong></li><li>else 的条件是 <strong>最后一个条件</strong></li><li>结合for循环，会将<strong>最后一个值</strong>执行for语句和else语句<strong>两次</strong></li><li><img src="/2019/09/23/Python循环-for/bd105252.png" alt="for-else"></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># for仅仅使用整数</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(i)  <span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="for循环与while循环"><a href="#for循环与while循环" class="headerlink" title="for循环与while循环"></a>for循环与while循环</h5><ul><li>任何for循环都可以转化为while循环</li><li>但是 while循环不一定能转化成for循环<ul><li>while 循环可以处理<strong>实数</strong></li><li>while 循环可以处理<strong>死循环</strong></li></ul></li></ul><h5 id="for-循环的嵌套"><a href="#for-循环的嵌套" class="headerlink" title="for 循环的嵌套"></a>for 循环的嵌套</h5><ul><li>嵌套循环可能会花费很长的时间来允许</li><li>用途<ul><li>显示<strong>列表</strong></li><li>平面</li></ul></li></ul><h5 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h5><ul><li>break 中断循环，直接跳出循环<ul><li>不会执行else语句</li><li><strong>结束多余</strong>的循环</li></ul></li><li>continue <strong>结束本次循环</strong>，继续下一次循环<ul><li>忽略continue之后的代码，返回循环头部继续一下次循环</li><li>主要起到 <strong>筛选作用</strong></li></ul></li><li>break 和 continue <strong>必须搭配 if</strong> 进行判断</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="循环的三种方式"><a href="#循环的三种方式" class="headerlink" title="循环的三种方式"></a>循环的三种方式</h5><ol><li>while</li><li>for</li><li>死循环+break</li></ol><h5 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h5><ul><li>break</li><li>continue</li></ul><h5 id="else-1"><a href="#else-1" class="headerlink" title="else"></a>else</h5><ul><li>for-else：<ul><li>即将跳出循环</li><li>对最后一个计数器<strong>再次处理</strong></li></ul></li><li>while-else:<ul><li>对 <strong>临界值</strong> 进行处理</li></ul></li></ul><h5 id="while-风格"><a href="#while-风格" class="headerlink" title="while 风格"></a>while 风格</h5><ul><li>设定循环次数，包含了<strong>循环终止条件</strong></li><li><strong>变量值发生变化</strong></li><li><code>while Ture if break</code></li><li>常见错误：忘记自增或则自减</li><li>可以处理<strong>浮点数</strong><ul><li>num - 数值 &lt; 0.000001</li></ul></li></ul><h5 id="for-风格"><a href="#for-风格" class="headerlink" title="for 风格"></a>for 风格</h5><ul><li>循环条件  <strong>计数器 整数</strong><ul><li>常使用 range <ul><li>range(100)</li><li>range(1,100,1)</li><li>range(100,1,-10)</li></ul></li><li>不包含第二个值</li><li>默认步长  1</li><li><strong>步长不能为0</strong> -&gt; for不能实现死循环</li></ul></li></ul><h5 id="时间统计"><a href="#时间统计" class="headerlink" title="时间统计"></a>时间统计</h5><ul><li>time.time() 返回当前时间，以<strong>秒</strong>为单位</li><li>做减法可以得到<strong>时间差</strong></li><li>time.sleep(5)<ul><li>暂停5秒</li></ul></li></ul><h5 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h5><ol><li>添加<strong>临时变量</strong>，交换变量</li><li>对称赋值 <code>a,b = b,a</code><ul><li>先计算=号右边的表达式</li><li>交换数据</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;&lt;/a&gt;for循环&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Python中的for循环通过一个&lt;strong&gt;序列&lt;/strong&gt;中的&lt;strong&gt;每个值&lt;/strong&gt;来进行&lt;strong&gt;迭代&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;知道循环次数的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计数器控制的循环&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不需要使用变量来控制循环&lt;/li&gt;
&lt;li&gt;迭代环境，使用的是 &lt;strong&gt;可迭代的对象&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;列表&lt;/li&gt;
&lt;li&gt;元组&lt;/li&gt;
&lt;li&gt;字典&lt;/li&gt;
&lt;li&gt;集合&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for循环&lt;strong&gt;处理速度稍微快点&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;主要是&lt;strong&gt;计数器参与运算的&lt;/strong&gt;，不需要在循环体中再次编写&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for 循环的参数是&lt;strong&gt;正整数&lt;/strong&gt;–计数器&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python循环-while</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%BE%AA%E7%8E%AF-while/"/>
    <id>http://yoursite.com/2019/09/23/Python循环-while/</id>
    <published>2019-09-23T06:58:06.000Z</published>
    <updated>2019-09-23T07:09:40.704Z</updated>
    
    <content type="html"><![CDATA[<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><ul><li>条件表达式的<strong>结果或本身</strong>都被计算成 <strong>布尔型</strong></li><li>当<strong>条件不满足</strong>的时候，<strong>循环结束</strong></li><li>如：None , <code>&quot;&quot;</code>，0 都被<strong>转化</strong>成 False</li><li>True 继续循环<ul><li>1，” “, 1,-1,True,1.234</li></ul></li><li>False 推出循环<ul><li>None,0,””,False<a id="more"></a><h5 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h5></li></ul></li><li><strong>条件一直为True</strong>，循环会一直执行下去</li><li><strong>条件表达式是常量</strong></li></ul><h5 id="有限循环"><a href="#有限循环" class="headerlink" title="有限循环"></a>有限循环</h5><ul><li><strong>条件在循环过程中会发生改变</strong>，结束程序运行</li><li><strong>条件使用变量</strong><ul><li>且在循环过程中 <strong>变量的值发生变化</strong></li></ul></li></ul><h6 id="else"><a href="#else" class="headerlink" title="else"></a>else</h6><ul><li>while-else: <strong>正常退出循环的时候会执行的else语句</strong>，<strong>不满足条件的时候执行</strong><ul><li>包含 条件不满足退出</li><li>包含 continue语句</li><li>包含 <strong>刚开始条件就不满足</strong>1，直接执行else语句</li><li><strong>break</strong>跳出循环，不执行else语句</li></ul></li><li>else: 是条件表达式的<strong>临界点</strong>，处理临界点的</li></ul><h5 id="浮点数的科学表达式"><a href="#浮点数的科学表达式" class="headerlink" title="浮点数的科学表达式"></a>浮点数的科学表达式</h5><ul><li>正数： 8.16e12</li><li>负数： 8.16e-12</li><li>浮点数的<strong>尾数不确定性</strong>导致在循环中不能直接处理，需要<strong>通过和0做减法</strong>，<strong>阈值筛选</strong>来使用，否则容易出现你BUG</li><li>使用查询来判断浮点数<ul><li>num - num1&lt; 0.00000001</li></ul></li></ul><h4 id="连续的关系运算符"><a href="#连续的关系运算符" class="headerlink" title="连续的关系运算符"></a>连续的关系运算符</h4><ul><li>3 &gt; 2 &gt; 1 —-&gt; <code>3 &gt;2 and 2 &gt; 1</code></li><li>and 表达式</li><li>隐藏的and表达式</li></ul><h5 id="if-else-三元表达式"><a href="#if-else-三元表达式" class="headerlink" title="if -else 三元表达式"></a>if -else 三元表达式</h5><ul><li>值1 if 条件表达式 else 值2</li><li>True 值=值1</li><li>False 值= 值2</li></ul><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><ul><li><img src="/2019/09/23/Python循环-while/1cf613aa.png" alt="运算符优先级"></li></ul><h5 id="循环穷举-编程思想"><a href="#循环穷举-编程思想" class="headerlink" title="循环穷举-编程思想"></a>循环穷举-编程思想</h5><ul><li>用于计算 10x+20Y = 10000</li><li>确定x的取值范围，做循环，计算 对于的Y值，如果Y值复合条件，就输出</li></ul><h4 id="if-表达式的的编程思想"><a href="#if-表达式的的编程思想" class="headerlink" title="if-表达式的的编程思想"></a>if-表达式的的编程思想</h4><ul><li>无限划分，遍历每种情况</li></ul><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><ol><li>数据</li><li>指令</li></ol><h5 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h5><ul><li>需要使用 win32 包<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client  <span class="comment"># 系统客户端的包</span></span><br><span class="line">speaker = win32com.client.Dispatch(<span class="string">"SAPI.SPVOICE"</span>)  <span class="comment"># 系统接口</span></span><br><span class="line">speaker.Speak(<span class="string">"陈钰琪，1992年7月29日出生于四川省成都市"</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="输入输出的重定向"><a href="#输入输出的重定向" class="headerlink" title="输入输出的重定向"></a>输入输出的重定向</h5><ul><li>使用符号</li><li><code>&gt;</code>  写入文本，覆盖 </li><li><code>&gt;&gt;</code>  写入文本，追加</li><li><code>&lt;</code> 从文件中读取</li><li><strong>可以连接配合使用</strong></li></ul><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><ul><li>空对象 。</li><li>属于 NoneType类型</li><li>在条件表达式中会自动转化为 False</li></ul><h4 id="嵌套逻辑"><a href="#嵌套逻辑" class="headerlink" title="嵌套逻辑"></a>嵌套逻辑</h4><ul><li>特别注意： 层级结构 空格或Tab不能混用</li></ul><ol><li>不是  if- elif- elif-else</li><li>是  if - if - if</li><li>条件的<strong>等级是并列,且满足其中一个条件</strong>的情况下，使用if - elif 语句<ul><li>条件的<strong>顺序</strong>是相连的，非顺序，需要添加区域条件</li><li><strong>隐含条件</strong></li><li>对嵌套的if-if 可以<strong>简化</strong></li></ul></li><li>条件的的<strong>等级是承接，必须全部满足的</strong>的情况下，使用 if-else 语句</li></ol><h4 id="运算符的优先级和结合性"><a href="#运算符的优先级和结合性" class="headerlink" title="运算符的优先级和结合性"></a>运算符的优先级和结合性</h4><ul><li>运算符的<strong>优先级</strong>和<strong>结合方向</strong>决定了<strong>运算符的计算顺序</strong></li><li>结合性：同意优先级下表达式的计算顺序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;while循环&quot;&gt;&lt;a href=&quot;#while循环&quot; class=&quot;headerlink&quot; title=&quot;while循环&quot;&gt;&lt;/a&gt;while循环&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;条件表达式的&lt;strong&gt;结果或本身&lt;/strong&gt;都被计算成 &lt;strong&gt;布尔型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;条件不满足&lt;/strong&gt;的时候，&lt;strong&gt;循环结束&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如：None , &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;，0 都被&lt;strong&gt;转化&lt;/strong&gt;成 False&lt;/li&gt;
&lt;li&gt;True 继续循环&lt;ul&gt;
&lt;li&gt;1，” “, 1,-1,True,1.234&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;False 推出循环&lt;ul&gt;
&lt;li&gt;None,0,””,False&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
