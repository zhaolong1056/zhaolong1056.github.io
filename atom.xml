<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夕阳西下，断肠人在天涯</title>
  
  <subtitle>好好学习，天天向上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-23T07:29:37.132Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhao long</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python列表，字典，集合详解</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Python列表，字典，集合详解/</id>
    <published>2019-09-23T07:26:40.000Z</published>
    <updated>2019-09-23T07:29:37.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表详细-元组详细-集合详细-字典详细-迭代器"><a href="#列表详细-元组详细-集合详细-字典详细-迭代器" class="headerlink" title="列表详细  元组详细  集合详细  字典详细 迭代器"></a>列表详细  元组详细  集合详细  字典详细 迭代器</h3><p>object.<strong>hash</strong>(self)<br>    * Called by built-in function hash() and for operations on members of hashed collections <strong>including set, frozenset, and dict</strong>.</p><a id="more"></a><p><code>hashable</code><br>    An object is hashable if it has a hash value which <strong>never changes</strong> during its lifetime<br>    (it needs a <strong>hash</strong>() method), and can be compared to other objects (it needs an <strong>eq</strong>() method).<br>    <strong>Hashable objects which compare equal must have the same hash value</strong>.<br>    Hashability makes an object usable as a dictionary key and a set member,<br>    because these <strong>data structures use the hash value internally.</strong><br>    hashable 可以用做dict的key和set的number，这些数字类型内部元素的可以hashbale</p><pre><code>&gt; Most of Python’s immutable built-in objects are hashable;&gt; mutable containers (such as lists or dictionaries) are not; &gt; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable.</code></pre><p>   不可变内置数据类型 是 hashable :str  frozenset<br>   可变容器类型 是 unhashable: list  dict    <code>unhashable type: &#39;set&#39;</code><br>   不可变容器类型元素是hashable的话，他们才是hashable：tuple fronzenset</p><ul><li><img src="/2019/09/23/Python列表，字典，集合详解/5cd91dcb.png" alt="哈希"><br>Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id().</li></ul><h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h4><h5 id="列表的构造"><a href="#列表的构造" class="headerlink" title="列表的构造"></a>列表的构造</h5><ol><li>使用<strong>方括号</strong><code>[]</code><strong>表示空列表</strong></li><li><strong>使用方括号<code>[]</code>,其中逗号<code>,</code>分割元素</strong></li><li>使用<strong>列表解析</strong>，<code>[x for x in iterable]</code></li><li>使用<strong>类型构造函数</strong>，<code>list()</code>或者<code>list(iterable)</code><ul><li>使用构造函数构造列表，<strong>列表的元素和iterable的元素相同且顺序相同</strong></li><li>没有参数，返回一个空列表<h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5></li></ul></li></ol><ul><li><img src="/2019/09/23/Python列表，字典，集合详解/11117d30.png" alt="常规的内存结构"></li><li><img src="/2019/09/23/Python列表，字典，集合详解/58be7780.png" alt="list的内存结构"></li><li>list是<strong>内存中的一段地址的集合</strong>，<strong>赋值是从一个地址的集合转到另一个地址的集合</strong><ul><li><strong>字符串存放的是一个地址</strong>，<strong>list是一堆地址</strong></li></ul></li><li><strong>list内部的存储的是元素的地址，通过索引进行操作，引用</strong></li><li><strong>list内部的元素是可以变化的，可以添加元素，删除元素等操作，可以单独修改引用地址</strong></li><li><strong>list内部的元素类型是不固定的，list只记录元素的地址，通过索引调用</strong></li><li><strong>修改单独元素不会影响list的值，只有整体赋值才能影响list</strong>，也就是将list指向新的地址段</li></ul><h6 id="list特点"><a href="#list特点" class="headerlink" title="list特点"></a>list特点</h6><ul><li>多个变量组成的集合，每个变量可以<strong>存储不同的地址</strong><ul><li><strong>可以包含不同类型的变量地址</strong></li></ul></li><li>对list中的元素进行增删改，不会影响list</li><li><strong>每个元素都有自己的独立地址</strong></li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><ul><li><strong>从0开始，通过索引操作元素</strong>，修改元素</li><li>索引：[0-len(list)-1] 或者 [0,-1]</li><li>正向索引和负向索引<ul><li>负向索引 <code>-m = len(list)-m</code></li></ul></li><li>索引的切片操作[m,n] 包含m，不包含n</li></ul><h5 id="⚠-循环"><a href="#⚠-循环" class="headerlink" title="⚠ 循环"></a>⚠ 循环</h5><ol><li>遍历元素  <code>for x in list:</code><ul><li>x是元素的值，而不是元素，data = mylist[1]，元素的copy，副本</li><li><strong>只能打印列表元素的值</strong></li><li>不能对元素进行修改等操作</li></ul></li><li>下标循环   <code>for i in range(len(list))</code><ul><li>i – 是<strong>索引</strong></li><li>list[i] 可以<strong>操作元素</strong>，包括打印输出，修改操作</li></ul></li></ol><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><ul><li>del 是关键字 属于<strong>声明</strong></li><li>del是递归定义的，与定义赋值的方式非常相似</li><li><strong>删除列表会自左向右递归删除每个目标</strong></li><li>Deletion of a name removes the binding of that name from the local or global namespace, depending on whether the name occurs in a global statement in the same code block.</li><li>删除名称将删除名称与本地或全变量的绑定</li><li>相当于内存回收</li><li>删除list的元素的时候，会出现索引越界的问题 del list[1]</li><li><img src="/2019/09/23/Python列表，字典，集合详解/61eaf59d.png" alt="删除索引越界"><ul><li>添加break语句，不会出现越界的问题</li></ul></li><li><strong>删除一个元素之后，索引及时变化，会向左移动</strong><ul><li>list是一个比较紧凑的数据结构</li></ul></li></ul><h5 id="列表的运算符"><a href="#列表的运算符" class="headerlink" title="列表的运算符"></a>列表的运算符</h5><ol><li>in / not in<ul><li>成员运算符，判断是否存在与列表中</li><li>只会判断第一层的元素</li><li>True False</li></ul></li><li>+<ul><li>列表的<strong>元素拼接</strong></li><li>归并</li></ul></li><li>*<ul><li>列表的<strong>元素重复</strong></li></ul></li></ol><h4 id="列表的嵌套"><a href="#列表的嵌套" class="headerlink" title="列表的嵌套"></a>列表的嵌套</h4><ul><li>列表的<strong>元素是列表</strong></li><li><strong>嵌套列表的访问需要使用嵌套for语句</strong></li><li>表示<strong>矩阵</strong></li><li>常见的嵌套列表是<strong>单个元素和列表元素同时存在</strong>，打印时小心处理,str有索引，但是输出不合理，int没有索引</li></ul><h5 id="isinstance-object-classinfo"><a href="#isinstance-object-classinfo" class="headerlink" title="isinstance(object, classinfo)"></a>isinstance(object, classinfo)</h5><ul><li>判断object是否是classinfo的实例</li><li>Return true if the <strong>object argument is an instance of the classinfo argument</strong>, or of a (direct, indirect or virtual) subclass thereof.</li></ul><h5 id="列表的常见方法"><a href="#列表的常见方法" class="headerlink" title="列表的常见方法"></a>列表的常见方法</h5><ul><li>Lists implement all of the common and mutable sequence operations.</li><li><strong>列表实现所有的常见和可变序列操作</strong></li><li>支持基本的序列操作</li></ul><p>1.append()<br>    * 添加元素到最后一个位置<br>    * <strong>把参数当作一个元素</strong></p><ol start="2"><li>index()<ul><li>查找第一个出现的索引</li><li><strong>只会查找list的元素，不会进入元素内部查找</strong></li></ul></li><li>count()<ul><li>统计元素出现的次数</li></ul></li><li>reverse()<ul><li>将列表元素反转</li><li>顺序反转，<strong>不排序</strong></li></ul></li><li>sort(*, key=None, reverse=False) <ul><li>按照元素的大小进行排序</li><li>reverse=True 从大到小</li><li>不合适嵌套的列表</li></ul></li><li>clear()<ul><li>序列的操作</li><li>清空列表</li></ul></li><li>pop()<ul><li>弹出最后一个元素</li><li>返回最后一个元素，并且列表也会发生变化</li></ul></li><li>remove()<ul><li>删除列表中的默认元素</li><li>没有返回值</li></ul></li><li>insert() <ul><li>相当于 s[i:i] = [x])</li><li><strong>在索引位置插入元素，之前的后移</strong></li></ul></li></ol><h5 id="list的拷贝"><a href="#list的拷贝" class="headerlink" title="list的拷贝"></a>list的拷贝</h5><ul><li>python是地址赋值，地址引用</li><li>在list中<ul><li><code>=</code>简单的地址引用</li><li><strong>两个变量指向同一个list</strong></li><li>is -&gt; True</li><li><img src="/2019/09/23/Python列表，字典，集合详解/998b897f.png" alt="引用赋值"></li><li>节约内存</li><li>数据共享，一个修改，另一个变量的值也发生变化了</li></ul></li></ul><ol start="2"><li>shadow copy 浅拷贝<ul><li>s.copy()</li><li>creates a shallow copy of s (same as s[:])</li><li>浅拷贝  类似第一层的切片</li><li>第二层列表共享</li><li><img src="/2019/09/23/Python列表，字典，集合详解/c9321bf6.png" alt="浅拷贝"></li><li>和 copy库中的copy.copy 功能一致</li></ul></li><li>deep copy 深拷贝<ul><li>递归拷贝对象</li><li>所有的数据都保存为副本</li><li>数据之间独立，不共享</li></ul></li></ol><ul><li>浅复制和深复制之间的区别<strong>仅与复合对象</strong>（包含其他对象的对象，如列表或类实例）相关</li><li>A shallow copy constructs a new compound object and then (to the extent possible) <strong>inserts references into it</strong> to the objects found in the original.</li><li>A deep copy constructs a new compound object and then, <strong>recursively, inserts copies into it</strong> of the objects found in the original.</li><li>浅拷贝是将它的<strong>引用</strong>插入到原始对象中</li><li>深拷贝是<strong>递归方式将复制对象</strong>插入到原始对象中找到的对象<ul><li>深拷贝会复制它可能复制的所有内容</li><li>递归对象（直接或间接包含对自身的引用的复合对象）可能会导致递归循环。</li></ul></li></ul><h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h4><ul><li>元组属于<strong>不可变序列</strong>，用于<strong>存储异构数据的集合</strong></li><li>构造<ol><li><code>()</code> 表示空元组</li><li>单例元组使用   a trailing comma for a singleton tuple <strong>末尾逗号</strong> <code>（a,）</code></li><li>使用逗号分割元素</li><li>函数内置函数tuple()</li></ol><ul><li>Note that it is <strong>actually the comma which makes a tuple</strong>, not the parentheses. </li><li><strong>本质上是由逗号确定元组的</strong></li><li><strong>可以不加括号</strong>，但是不常用</li></ul></li><li>本质<ul><li>元素属于序列，基本满足序列的操作</li><li>通过索引进行元素的操作，只能打印</li><li><strong>元素 不可变</strong></li><li><img src="/2019/09/23/Python列表，字典，集合详解/37ed335f.png" alt="元组内存结构"></li><li>和list对比，存储的是<strong>地址常量</strong>，而且list中存储的是<strong>地址变量</strong></li></ul></li><li>索引<ul><li>正向索引</li><li>负向索引</li><li>切片操作 左开右闭合 [)</li></ul></li><li>元素符号<ul><li><ul><li>拼接 </li></ul></li><li><ul><li>复制</li></ul></li><li>in 成员操作符<ul><li>in 判断第一层的元素</li></ul></li></ul></li><li>循环<ul><li>元素遍历循环</li><li>下标循环</li></ul></li><li>max,min<ul><li>返回最大，最小的元素</li><li>如果有嵌套的，报错</li></ul></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>A set object is an <strong>unordered collection</strong> of <strong>distinct hashable objects</strong></li><li><strong>不同哈希对象的无序集合</strong></li><li><strong>不重复元素的无序集合</strong></li><li>不支持索引<ul><li>用途<ul><li>成员资格测试</li><li>从序列中删除重复项</li><li>数学运算（差集，交集，补集）</li></ul></li></ul></li><li><strong>无序</strong>集合，不记录元素的元素的位置和插入顺序，不支持索引，切片或其他类似序列的操作</li><li>有两种类型<code>set</code>和<code>frozenset</code></li></ul><ol><li>class set([iterable]) <ul><li>The set type is <strong>mutable</strong> — the contents <strong>can be changed</strong> using methods like add() and remove(). </li><li>Since it is mutable, it has <strong>no hash value</strong> and cannot be used as either a dictionary key or as an element of another set. </li></ul></li><li>class frozenset([iterable]) <ul><li>The frozenset type is <strong>immutable and hashable</strong> — its contents cannot be altered after it is created; </li><li>it can therefore be used as a dictionary key or as an element of another set.<h5 id="构造set"><a href="#构造set" class="headerlink" title="构造set"></a>构造set</h5></li></ul></li></ol><ul><li>使用大括号<code>{}</code>定义</li><li>元素之间用<strong>逗号</strong>隔开</li><li>set([iterable])  可迭代对象拆分成了 集合</li><li><code>{}</code> 定义的是<strong>dict</strong><ul><li>空set使用set()定义  输出也是 <code>set()</code></li><li>set(set)：使用set重新创建set，<strong>两个不一致</strong></li></ul></li><li>set集合没有顺序</li><li>从字典转换成集合 注意：<strong>只有key值</strong></li><li><strong>集合不能进行单独元素的操作</strong></li></ul><h5 id="set的函数"><a href="#set的函数" class="headerlink" title="set的函数"></a>set的函数</h5><ol><li>add(elem) <ul><li>Add element elem to the set.</li><li>注意 set的元素是hashable的，所以不能添加list和set，</li></ul></li><li>update(*others) <ul><li>Update a set with the <strong>union</strong> of itself and others</li><li><strong>参数是iterable</strong> TypeError: ‘int’ object is not iterable</li><li>会将可迭代对象的每个元素和原set进行union操作</li></ul></li><li>remove<ul><li>删除元素,但是元素不存在时，会报错</li><li>KeyError: 1</li><li>Remove an element from a set; it must be a member.</li><li>If the element is not a member, raise a KeyError.</li></ul></li><li>discard(elem) <ul><li>Remove element elem from the set if it is present.</li><li>删除元素，如果存在与set中，则删除</li><li>不存在与set中，do nothing</li></ul></li><li>pop<ul><li>Remove and return an arbitrary element from the set. Raises KeyError if the set is empty</li><li>从集合中删除和返回<strong>任意元素</strong></li><li>集合为空，会引发keyError错误</li></ul></li><li>clear <ul><li>Remove all elements from the set.</li></ul></li><li>difference(*others) <ul><li>set - other - … </li><li>Return a new set with elements <strong>in the set that are not in the others.</strong></li><li>返回一个集合，元素在set中，而不在other中</li><li>表示差集 A.difference(B) == A-B</li></ul></li><li>isdisjoint(other) <ul><li>Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set.</li><li><strong>没有交集</strong></li></ul></li></ol><h5 id="set的循环"><a href="#set的循环" class="headerlink" title="set的循环"></a>set的循环</h5><ul><li>没有索引操作，只能使用in操作符<strong>元素遍历</strong></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>tuple</li><li>set</li><li>list</li></ul><h5 id="set无法单独操作每个元素"><a href="#set无法单独操作每个元素" class="headerlink" title="set无法单独操作每个元素"></a>set无法单独操作每个元素</h5><ul><li>循环遍历中的是 <strong>副本</strong></li><li>可以修改副本，但是修改不了原本</li><li><strong>如果要操作单个元素，可以转化成list，修改之后，再次转换回来</strong></li></ul><h5 id="集合的运算符"><a href="#集合的运算符" class="headerlink" title="集合的运算符"></a>集合的运算符</h5><ol><li><p>-</p><ul><li>差集</li><li>A - B：A中存在的元素，B中不存在</li></ul></li><li><p>&amp;</p><ul><li>交集</li><li>A &amp; B：元素存在于A中，也存在B中</li><li>和集合的前后顺序无关</li></ul></li><li><p>|</p><ul><li>并集</li><li>返回一个集合</li><li>A | B: 元素存在与A或者B中</li></ul></li><li><p>^</p><ul><li>并集 - 交集</li><li>A ^ B: 分别存在A或者B集合中</li></ul></li><li><p>==</p><ul><li>判断A和B元素是否相等</li><li>只要元素分别存在与两个集合中返回True</li><li>不考虑顺序，set没有顺序</li></ul></li><li><p>in </p><ul><li>用于<strong>判断元素是否是否属于集合</strong></li><li><strong>如果是 set in set 返回False</strong>11<h5 id="集合的关系运算符"><a href="#集合的关系运算符" class="headerlink" title="集合的关系运算符"></a>集合的关系运算符</h5></li></ul></li><li><p>issubset(other)  包含</p><ul><li>set &lt;= other </li><li>Test whether every element in the set is in other.</li><li>测试set中的元素是否存在与other</li><li>set &lt; other </li><li>Test whether the set is a proper subset of other, that is, <strong>set &lt;= other and set != other</strong>.</li><li>测试set的是不是other的子集，</li></ul></li><li><p>issuperset(other)   被包含</p><ul><li><p>set &gt;= other </p></li><li><p>Test whether every element in other is in the set.</p></li><li><p>set &gt; other </p></li><li><p>Test whether the set is a proper superset of other, that is, set &gt;= other and set != other.</p></li></ul></li></ol><h4 id="mapping-type-—-gt-dict"><a href="#mapping-type-—-gt-dict" class="headerlink" title="mapping type —&gt; dict"></a>mapping type —&gt; dict</h4><ul><li>映射</li><li>A mapping object maps hashable values to arbitrary objects. </li><li>映射对象：<strong>可哈希值映射到任意的对象</strong></li><li>mapping 是可变类型，目前标准映射只有dict</li></ul><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul><li>Key：几乎任意值，但是必须是可哈希的</li><li>Value：任意值<ul><li>list，dict和set 不能作为key</li></ul></li><li>Dictionaries can be created by <strong>placing a comma-separated list of key</strong>: <strong>value pairs within braces</strong></li><li>可变数据类型，存储任意类型对象</li><li>集合的加强版，可以使用key调用value；key和set的元素类似</li><li>key的value<strong>可以被覆盖，按照录入顺序</strong><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5></li><li>class dict(**kwarg)  关键字参数<ul><li>name=”zhaolong” 其中<strong>前一个不需要引号</strong></li></ul></li><li>class dict(mapping, **kwarg)   映射类型<ul><li>如 zip函数</li></ul></li><li>class dict(iterable, **kwarg)   可迭代一对<ul><li>[(,)]</li></ul></li><li>dict() 或者 {} <strong>创建空字典</strong></li><li>通过key值引用value dict[key]</li></ul><h5 id="映射函数"><a href="#映射函数" class="headerlink" title="映射函数"></a>映射函数</h5><ul><li><p>zip(*iterables) </p><ul><li><p>参数是多个可迭代数据，或者可迭代的列表</p></li><li><p>Make an iterator that aggregates elements from each of the iterables.</p></li><li><p><strong>根据多个迭代对象的对应元素创建一个迭代对象</strong></p></li><li><p>返回一个<strong>元组的迭代器</strong>，<strong>元素来自与参数迭代对象的对应元素</strong></p></li><li><p>The iterator stops when the shortest input iterable is exhausted. </p></li><li><p>当其中任意一个可迭代对象停止时，结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span><span class="params">(*iterables)</span>:</span></span><br><span class="line"><span class="comment"># zip('ABCD', 'xy') --&gt; Ax By</span></span><br><span class="line">sentinel = object()</span><br><span class="line">iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> iterables]</span><br><span class="line"><span class="keyword">while</span> iterators:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterators:</span><br><span class="line">        elem = next(it, sentinel)</span><br><span class="line">        <span class="keyword">if</span> elem <span class="keyword">is</span> sentinel:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result.append(elem)</span><br><span class="line">    <span class="keyword">yield</span> tuple(result)</span><br></pre></td></tr></table></figure></li><li><p>zip() 函数可用于解压缩列表</p></li></ul></li></ul><h5 id="字典的更新"><a href="#字典的更新" class="headerlink" title="字典的更新"></a>字典的更新</h5><ol><li>in </li></ol><ul><li><strong>判断键值是否存在</strong>，不判断值</li><li>key in d <ul><li>Return True if d has a key key, else False.</li></ul></li><li>key not in d <ul><li>Equivalent to not key in d.</li></ul></li></ul><p>2.del d[key]<br>    * Remove d[key] from d. Raises a KeyError if key is not in the map.</p><ol start="3"><li>clear() <ul><li>Remove all items from the dictionary.</li></ul></li><li>len(d) <ul><li>Return the number of items in the dictionary d.</li></ul></li><li>copy() <ul><li>Return a shallow copy of the dictionary.</li></ul></li><li>get(key[, default]) <ul><li>Return <strong>the value for key</strong> if key is in the dictionary, else default.</li><li>If default is not given, it <strong>defaults to None</strong>, so that this method <strong>never raises a KeyError</strong>.</li></ul></li><li>items() <ul><li>Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects.</li></ul></li><li>keys() <ul><li>Return a new view of the dictionary’s keys. See the documentation of view objects.</li></ul></li><li>values() <ul><li>Return a new view of the dictionary’s values. See the documentation of view objects.</li><li>a <strong>set-like object</strong> providing <strong>a view on D’s items</strong></li><li>都是可以迭代的 </li></ul></li><li>update([other]) <ul><li>Update the dictionary with the <strong>key/value pairs from other</strong>, </li><li>overwriting existing keys. Return None.</li><li>会使用参数dict的键值对更新dict，如果存在，覆盖；如果不存在，返回None</li><li>会更新dict</li></ul></li><li>setdefault(key[, default]) <ul><li>If key is in the dictionary, return its value. </li><li>If not, <strong>insert key with a value of default and return default</strong>. </li><li>default defaults to None.</li></ul></li></ol><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li><img src="/2019/09/23/Python列表，字典，集合详解/2eddd0a3.png" alt="迭代器原理"></li><li>迭代器协议<ul><li><strong>iter</strong></li><li><strong>next</strong></li><li>StopIteration</li></ul></li><li>常用在<code>for in</code>环境中</li><li>可迭代对象 和 迭代器 的协议稍微不一致</li><li><img src="/2019/09/23/Python列表，字典，集合详解/18542041.png" alt="可迭代对象"></li><li><img src="/2019/09/23/Python列表，字典，集合详解/a035e139.png" alt="迭代器"></li></ul><h4 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h4><h5 id="列表生成式：-x-for-x-in-range-100-一次性全部删除，浪费内存"><a href="#列表生成式：-x-for-x-in-range-100-一次性全部删除，浪费内存" class="headerlink" title="列表生成式：[x for x in range(100)]  一次性全部删除，浪费内存"></a>列表生成式：[x for x in range(100)]  一次性全部删除，<strong>浪费内存</strong></h5><ul><li>非常暴力的占用内存，严重浪费<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5></li><li>一次生成一个数据，节约内存</li><li>使用关键字 <code>yield</code>生成生成器函数</li><li>或者<strong>生成器表达式()</strong><h6 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h6></li><li>(x for x in range(100))</li><li>使用 next()</li></ul><h5 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h5><ul><li>和常规函数没有区别</li><li>但是 在内部使用了关键字 <code>yield</code></li><li>其中 函数名：函数</li><li>函数调用：函数名() 的类型时generator</li><li>第一次执行：到达yield 返回内存</li><li>第二次调用：继续上一次执行的地方继续执行</li><li>注意<ul><li>使用的时候，首先 将函数生成器赋值给变量，以防每次使用生成一个<strong>新的生成器</strong>  x=go()</li><li>yield 在函数常和for<strong>搭配使用</strong></li><li>生成器函数只能通过<code>next()</code>调用<ul><li>因为 函数名() 已经变成一个 generator 了</li><li>必须使用 next()</li></ul></li><li>常用于<strong>读取文件</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;列表详细-元组详细-集合详细-字典详细-迭代器&quot;&gt;&lt;a href=&quot;#列表详细-元组详细-集合详细-字典详细-迭代器&quot; class=&quot;headerlink&quot; title=&quot;列表详细  元组详细  集合详细  字典详细 迭代器&quot;&gt;&lt;/a&gt;列表详细  元组详细  集合详细  字典详细 迭代器&lt;/h3&gt;&lt;p&gt;object.&lt;strong&gt;hash&lt;/strong&gt;(self)&lt;br&gt;    * Called by built-in function hash() and for operations on members of hashed collections &lt;strong&gt;including set, frozenset, and dict&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串详解</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Python字符串详解/</id>
    <published>2019-09-23T07:19:37.000Z</published>
    <updated>2019-09-23T07:25:42.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串详解"><a href="#字符串详解" class="headerlink" title="字符串详解"></a>字符串详解</h3><h4 id="eval-和-evec"><a href="#eval-和-evec" class="headerlink" title="eval 和 evec"></a>eval 和 evec</h4><ol><li>eval：<ul><li>eval 语句用来计算存储在字符串中的<strong>有效表达式</strong></li><li>内置函数</li><li>可以转化为实数,<strong>只能处理字符串形式的表达式</strong></li><li>常见的使用：<code>num = eval(input(&quot;输入数据:&quot;))</code></li><li>The expression argument is parsed and evaluated as a Python expression </li><li><code>eval(&quot;2+2&quot;)</code></li><li><strong>参数是 “字符串”</strong></li><li>eval() arg 1 must be a string, bytes or code object</li><li><strong>将文本当作表达式使用</strong><a id="more"></a></li></ul></li><li>exec：<ul><li>exec 语句 用来执行存储在字符串或文件中的<strong>python语句</strong></li><li><code>exec(print(&quot;hello world&quot;))</code></li><li>This function supports dynamic execution of Python code. object must be either a string or a code object</li><li>The source may be a string representing one or more Python statements</li><li><strong>处理字符串形式的python语句</strong></li><li><strong>将文本当作语句执行</strong></li><li>exec() arg 1 must be a string, bytes or code object</li></ul></li></ol><h5 id="repr"><a href="#repr" class="headerlink" title="repr"></a>repr</h5><ul><li>Return a string containing a printable representation of an object.</li><li>For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a <strong>repr</strong>() method.</li><li><strong>返回一个包含可打印表示的字符串</strong></li><li>可以直接交给eval使用，但是输出的结果依然是repr()的参数 </li><li><strong>主要用来取得对象的规范字符串表示</strong>，反引号也可以完成相同的功能</li><li>大多数时候<code>eval(repr(object)) == object</code>  <ul><li>repr 加了一层引号</li><li>eval 去掉一层引号</li></ul></li><li>使用<strong>repr</strong>方法控制repr的返回内容</li><li><img src="/2019/09/23/Python字符串详解/10ed7d8f.png" alt="repr和str"></li></ul><h4 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h4><h5 id="字符串的三种风格"><a href="#字符串的三种风格" class="headerlink" title="字符串的三种风格"></a>字符串的三种风格</h5><ol><li>单引号<ul><li>一般用于字符</li></ul></li><li>双引号<ul><li>一般用于字符串</li></ul></li><li>三引号<ul><li>主要解决多行字符串的问题<h5 id="字符串的基础单位"><a href="#字符串的基础单位" class="headerlink" title="字符串的基础单位"></a>字符串的基础单位</h5></li></ul></li></ol><ul><li><strong>字符</strong> - 最小的字符单位</li><li>unicode字符<ul><li>字母，符号(单的)，汉字</li></ul></li></ul><h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><ul><li>字符在Python的定义的是<code>bytes</code>，也就是<strong>字节流</strong>，包含多个字符</li><li>python中定义字符使用<code>b&#39;&#39;</code></li><li>或者使用 str.encode()</li><li>bytes can only contain ASCII literal characters</li><li>简单的字母</li></ul><h5 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h5><ul><li>字符串属于序列，可以<strong>使用切片操作</strong>，索引从0开始</li><li><strong>正向索引和负向索引可以混合使用</strong></li></ul><h5 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h5><ul><li>字符串<strong>不支持元素赋值</strong></li><li>‘str’ object does not support item assignment</li><li>字符串是不可变数据类型</li><li><strong>可以对字符串赋值为新的常量字符串</strong></li><li><strong>字符串除非重新赋值，否则字符串不会改变</strong></li></ul><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><blockquote><p>采用某些方式暂时取消该字符本来的含义<br>python中使用<code>\+字符</code>方式表示</p><ul><li><img src="/2019/09/23/Python字符串详解/6cffef75.png" alt="Python常见的转义字符"></li><li>作用<ol><li><strong>表示不可打印字符</strong><ul><li>\b \t \a</li><li>退格 tab 蜂鸣</li></ul></li><li>解决字符串中的<code>\t</code>等<strong>引起的错误</strong>–&gt; ‘\t’ </li></ol></li><li>最常用于目录 <code>\\</code> 表示<code>\</code>,而不是<strong>转义符号</strong><ul><li>主要用于windows系统中，windows系统中<code>\</code>用于目录分隔符</li></ul></li></ul></blockquote><h5 id="字符串常见运算符"><a href="#字符串常见运算符" class="headerlink" title="字符串常见运算符"></a>字符串常见运算符</h5><ol><li>+<ul><li>字符串的<strong>拼接</strong></li><li>两边只能是str，不能出现int</li><li>TypeError: can only concatenate str (not “int”) to str</li></ul></li><li><ul><li><ul><li>字符串的<strong>乘法</strong></li><li>序列的<em>乘法</em></li><li><strong>只能和整数相乘</strong></li><li>TypeError: can’t multiply sequence by non-int of type ‘str’</li><li>TypeError: can’t multiply sequence by non-int of type ‘float’</li></ul></li></ul></li><li>[]<ul><li>字符串的<strong>截取</strong></li><li>序列的<strong>截取</strong></li><li>str[n]</li><li>str[m,n,step]</li></ul></li><li>in / not in<ul><li>成员操作符</li><li>ch in str: ch是否存在于str中，返回True和False</li><li>ch 可以是<strong>单个字符，也可以是字符串</strong></li></ul></li></ol><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><ul><li><code>\n</code>和<code>\r\n</code> 都起到换行符</li><li>和<b>平台有关，一般可以兼容，效果是一样</b></li><li><table><thead><tr><th>\n</th><th>回车，光标在下一行</th></tr></thead><tbody><tr><td>\r</td><td>换行，光标在上一行</td></tr></tbody></table></li></ul><h4 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h4><ul><li><p><code>format()</code></p></li><li><p>Convert a value to a “formatted” representation, as controlled by format_spec. </p></li><li><p>The interpretation of format_spec will depend on the type of the value<br>argument</p></li><li><p>“Format specifications” are used within replacement fields contained<br>within a format string to define how individual values are presented</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;  # 填充字符</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;   # 对其角度</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;     # 标志，仅对数字有效</span><br><span class="line">width           ::=  digit+   # 宽度</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;   # 数字千分位</span><br><span class="line">precision       ::=  digit+   # 精度</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;  #类型a</span><br></pre></td></tr></table></figure></li><li><p><img src="/2019/09/23/Python字符串详解/49d4d88f.png" alt="类型1"></p></li><li><p><img src="/2019/09/23/Python字符串详解/81291b59.png" alt="类型2"></p></li><li><p>用法 </p><ol><li>函数 <code>format(&quot;字符串&quot;,&quot;格式化表达式&quot;)</code></li><li>方法 <code>&quot;{}，{}，{}&quot;.format(字符串，字符串)</code></li></ol></li></ul><ol><li>函数<ul><li>参数：和格式字符串中的类型一致</li><li>函数 <strong>会将 数据 按照类型进行处理，转换成字符串</strong></li><li>ValueError: Unknown format code ‘f’ for object of type ‘str’</li></ul></li><li>格式化字符串<ul><li>“%s”.% num  一个完整的字符串 <strong>%替换内容</strong></li><li><img src="/2019/09/23/Python字符串详解/52c7c96e.png" alt="精细参数"></li><li><code>%[填充符号][对齐][宽度][,千分位][.精度][类型]</code><ul><li>填充：默认空格</li><li>对齐: &lt; &gt; =</li></ul></li></ul></li><li>特殊表现</li></ol><ul><li><code>%%</code>:<strong>特殊的转义字符</strong>，表示输出一个<code>%</code></li><li><a href="8.字符串格式化表达.py">%转移字符</a></li></ul><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><ul><li>Python2中，<strong>普通的字符是以8位的ASCII码进行存储的，而Unicode字符串则存储为16为Unicode字符串</strong>,使用的语法是在字符串前加<code>u</code></li><li>python3中, <strong>所有的字符串都是Unicode字符串</strong></li><li>ASCII格式没有中文，可以编译<ul><li>但是存储中文的话，不能通过编译，必须使用<code>utf-8</code></li></ul></li><li>utf-8和ASCII比较<ul><li>同等条件下，空间占用较大</li><li>utf-8  可以编译中文</li><li><strong>python3中默认字符集Unicode，默认编码格式utf-8</strong></li></ul></li></ul><h5 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h5><ul><li>Both string and bytes literals may optionally be prefixed with a letter ‘r’ or ‘R’; such strings are called raw strings and treat backslashes as literal characters. </li><li>As a result, in string literals, ‘\U’ and ‘\u’ escapes in raw strings are not treated specially.</li><li>格式： <code>r&quot;字符串&quot;</code><ul><li>但是如果字符串本身带着<code>&quot;</code>,r 不适用</li></ul></li></ul><h5 id="查看字符串帮助"><a href="#查看字符串帮助" class="headerlink" title="查看字符串帮助"></a>查看字符串帮助</h5><ul><li><p>dir(‘’)</p><ul><li>Without arguments, return the list of names in the current local scope. </li><li>With an argument, attempt to return <b>a list of valid attributes for that object.</b></li><li>If the object does not provide <strong>dir</strong>(), the function tries its best to gather information from the object’s <b><strong>dict</strong> attribute</b>, if defined, and from its type object. </li><li>The resulting list is not necessarily complete, and may be inaccurate when the object has a custom <strong>getattr</strong>(). </li><li><strong>输出包含对象所属类型的属性和方法的列表</strong></li><li>获取对象有<strong>哪些属性和方法</strong></li></ul></li><li><p>help()</p><ul><li>查看对象的<strong>具体属性的文档</strong></li><li>第一种风格：<code>”“.find</code> 使用<code>&lt;对象&gt;.&lt;方法/属性&gt;</code> 查看</li><li>第二种风格：<code>str.find</code> 使用<code>&lt;类型&gt;.&lt;方法/属性&gt;</code> 查看 </li></ul></li></ul><h5 id="字符串的方法和函数"><a href="#字符串的方法和函数" class="headerlink" title="字符串的方法和函数"></a>字符串的方法和函数</h5><ul><li><strong>字符串的方法和函数数量比较多</strong></li><li>字符串是<strong>不可变数据类型</strong>，他的方法都<strong>返回一个新的字符串</strong>，<strong>不会对原始的字符串产生影响</strong></li><li>常用方法和函数</li></ul><ol><li><p>str.capitalize() </p><ul><li>Return <strong>a copy of the string with its first character capitalized and the rest lowercased.</strong></li><li>返回一个<strong>首字母大写，其余字母小写的副本</strong></li><li><strong>只对英文字符起作用</strong></li></ul></li><li><p>str.center(width[, fillchar]) </p><ul><li>Return centered in a string of length width.</li><li>Padding is done using the specified fillchar (default is an ASCII space). </li><li>The original string is returned if width is less than or equal to len(s).</li><li><strong>返回一个长度是width的字符串，其中原本字符串居中，两边用fillchar填充</strong></li><li>fillchar 默认 <strong>空格</strong></li></ul></li><li><p>str.count(sub[, start[, end]]) </p><ul><li>Return the number of non-overlapping occurrences of substring sub in the range [start, end]. </li><li>Optional arguments start and end are interpreted as in slice notation.</li><li><strong>返回索引范围内的非重叠出现次数</strong></li><li><strong>切片默认是整个字符串</strong>1</li></ul></li><li><p>str.endswith(suffix[, start[, end]]) </p><ul><li>Return True if the string ends with <strong>the specified suffix</strong>, otherwise return False. </li><li>suffix can also be <strong>a tuple of suffixes to look for</strong>. </li><li>With optional start, test beginning at that position. With optional end, stop comparing at that position.</li><li>判断字符串是否是stuffix <strong>后缀</strong> 结尾</li><li><strong>后缀可以是个元组</strong></li><li><strong>本质上是判断以什么字符结尾</strong><ul><li>可以用作判断后缀</li></ul></li><li>相反的str.startswith(prefix[, start[, end]]) </li></ul></li><li><p>str.expandtabs(tabsize=8) </p><ul><li>返回一个副本，<strong>字符串中的tab键由指定的空格数替换</strong></li><li>默认的是8</li><li>Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size.</li></ul></li><li><p>str.find(sub[, start[, end]]) </p><ul><li>Return the <strong>lowest index</strong> in the string where substring sub is found within the slice s[start:end].</li><li>Optional arguments start and end are interpreted as in slice notation. Return <strong>-1</strong> if sub is not found.</li><li>查找函数，找不到返回 -1</li><li>注意<ul><li><strong>只是在需要知道sub在那个位置时，才使用find</strong></li><li>如果需要判断是否在字符串中，需要使用in</li></ul></li><li>rfind()<ul><li>Return the <strong>highest index</strong> in the string where substring sub is found,</li><li><strong>sub重复出现，返回最高的索引</strong></li></ul></li></ul></li><li><p>index(sub[, start[, end]]) </p><ul><li>Like find(), but raise <code>ValueError</code> when the substring is not found.</li><li>和find相似</li><li>但是当sub不存在的时候，报ValueError</li><li>rindex() 和 rfind() 类似</li></ul></li><li><p>判断函数</p><ul><li><p><strong>判断字符串是不是数字的，纯字符的等</strong></p></li><li><p><img src="/2019/09/23/Python字符串详解/76f39d58.png" alt="常见判断函数"></p></li><li><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>isalnum</td><td>一个<strong>字母数字</strong>字符串，不能出现汉字和其他符号</td></tr><tr><td>isalpha</td><td>一个<strong>字母</strong>字符串，所有字符全部是字母，不能包含数字</td></tr><tr><td>isascii</td><td>有acsii码组成的字符串，其中””空字符串也属于</td></tr><tr><td>isdecimal</td><td>十进制字符串</td></tr><tr><td>isdigit</td><td>数字字符串,和上面稍微不一样</td></tr><tr><td>isnumeric</td><td>所有字符都是数字</td></tr><tr><td>islower</td><td>判断小写</td></tr><tr><td>isspace</td><td><strong>空格字符串</strong>，不是空字符串；包含·’\t’,’\n’,’\r’等空白字符</td></tr><tr><td>istitle</td><td>标题字符串，第一个大写，其他字符小写,注意含有空格的情况下，<strong>每个空格后第一个字母都要大写</strong></td></tr></tbody></table></li><li><p>注意：<strong>判断字符串中字符的情况是在非空字符串的条件下</strong></p></li><li><p>注意：<strong>汉字没有大小写之分</strong></p><ul><li>当字符串中全部是汉字时，isupper和islower结果是False</li><li>当字符串中包含其他字符和汉字时，<strong>isupper和islower会忽略汉字进行判断</strong></li></ul></li></ul></li><li><p>可打印字符和空字符</p><ul><li>isspace()<ul><li><strong>字符串中只有空格字符且至少有一个字符</strong></li><li>空白字符：是Unicode数据库中定义的’others’和’Separator’字符</li></ul></li><li>isprintale()<ul><li><strong>字符串中所有字符是可打印的或则空字符串</strong></li><li>Nonprintable characters are those characters defined in the Unicode character database as “Other” or “Separator”, excepting the ASCII space (0x20) which is considered printable.</li><li>0x20 是<strong>空格，是可以打印的</strong></li><li><strong>在上下文环境中，repr()转移的字符是不可打印字符</strong></li><li><img src="/2019/09/23/Python字符串详解/056b29ea.png" alt="上下文环境的repr"></li></ul></li></ul></li><li><p>str.join(iterable) </p><ul><li>Return a string which is the concatenation of the strings in iterable</li><li>The separator between elements is the string providing this method.</li><li><strong>参数是可迭代的对象</strong></li><li><strong>分隔符参数提供了该方法</strong> </li><li>按照指定的字符作为<strong>间隔符</strong>和<strong>可迭代对象</strong>生成新的字符串</li></ul></li><li><p>str.rjust(width[, fillchar]) </p><ul><li>类似center，但是是<strong>左边填充</strong></li><li>ljust： <strong>右边填充</strong></li></ul></li><li><p>str.lower() / upper()</p><ul><li>对 中文字符无意义</li><li>字符全部转换成大写，或者小写</li><li>常用 <strong>忽略大小写</strong></li></ul></li><li><p>str.replace(old, new[, count]) </p><ul><li>如果没有count参数，则替换所有的old字符</li><li>如果有count参数，<strong>根据count的数量从前到后进行替换</strong></li></ul></li><li><p>str.strip([chars]) </p><ul><li><strong>返回一个已经删除了最前面或者最后面chars字符的字符串</strong></li><li>chars =None或者省略时，<strong>删除空格</strong></li><li>chars：<strong>要删除的字符集，不是前缀或后缀，是所有值的组合都被剥离</strong></li><li>The chars argument is not a prefix or suffix; rather, <strong>all combinations of its values are stripped</strong></li><li>有两个形同的 rstrip()和lstrip() 表示从右边或左边删除</li><li><strong>删除字符集中字符直到不属于集合中的字符截至，不能间断</strong></li></ul></li><li><p>str.zfill(width) </p><ul><li>Return a copy of the string left filled with ASCII ‘0’ digits to make a string of length width.</li><li>A leading sign prefix (‘+’/‘-‘) is handled by inserting the padding after the sign character rather than before</li><li><strong>在左边填充0达到指定的长度</strong></li><li>带有符号的对象，在<strong>符号和数值中间填充</strong></li></ul></li><li><p>str.swapcase() </p><ul><li>Return a copy of the string with uppercase characters converted to lowercase and vice versa.</li><li><strong>修改字符串中字符的大小写，大写转小写，小写转大写，字符级别的</strong></li></ul></li><li><p>str.translate(table) </p><ul><li>Return a copy of the string in <strong>which each character</strong> has been mapped through <strong>the given translation table.</strong></li><li><strong>每个元素对照翻译表</strong></li><li>The table must be an object that implements indexing via <strong>getitem</strong>(), typically a mapping or sequence.</li><li>翻译表必须可以通过<strong>gititem</strong>()，一般是<strong>映射和序列</strong></li><li>You can use str.maketrans() to create a translation map from character-to-character mappings in different formats.</li><li><strong>使用str,maketrans()创建字符-字符的映射</strong></li></ul></li><li><p>static str.maketrans(x[, y[, z]]) </p><ul><li>是一个静态方法</li><li>用于创建str.translate()的<strong>转换表</strong></li><li><strong>一个参数的话，必须是字典</strong>，将Unicode序列，字符映射到另一个Unicode序列</li><li><strong>两个参数，必须是两个长度相等的字符串</strong></li><li><strong>第三个参数表示指向None，翻译的时候也是None，表示的是省略</strong><h5 id="字符串的切割"><a href="#字符串的切割" class="headerlink" title="字符串的切割"></a>字符串的切割</h5></li></ul></li><li><p>str.split(sep=None, maxsplit=-1) </p><ul><li><strong>将字符串按照sep进行分割，返回包含字符的列表</strong></li><li>sep 默认是 空格，<ul><li>但是<strong>字符串前面或后面的空格不参与</strong> leading or trailing whitespace,在sep为None的情况下</li><li><strong>字符串中间的连续空格被当作一个处理</strong></li><li><strong>如果sep是其他字符，字符串中的空格也会被处理成一个元素</strong><code>&quot;&quot;</code><ul><li><strong>而且不会在换行的地方产生新的元素</strong>，<code>a\nv</code></li></ul></li></ul></li><li>maxsplit 限制切割次数<ul><li>默认 -1：即尽可能的分割</li><li>列表最大有 maxsplit+1个元素</li></ul></li></ul></li><li><p>str.splitlines([keepends]) </p><ul><li>按行切割</li><li>返回包含行的列表</li><li><code>keepends</code> 保留边界字符，也就是换行符，默认<strong>不保留</strong></li><li><img src="/2019/09/23/Python字符串详解/e3ba965f.png" alt="换行符"></li></ul></li></ol><h5 id="字符串中三种数字的对比"><a href="#字符串中三种数字的对比" class="headerlink" title="字符串中三种数字的对比"></a>字符串中三种数字的对比</h5><ul><li><p>在unicode定义中，一下所有的都是数字</p></li><li><p><img src="/2019/09/23/Python字符串详解/ff4bf9e4.png" alt="wiki定义"></p></li><li><p><a href="14.数字字符串的区别.py">示例</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">⅐   ⅑   ⅒   ⅓   ⅔   ⅕   ⅖   ⅗   ⅘   ⅙   ⅚   ⅛   ⅜   ⅝   ⅞   ⅟</span><br><span class="line">Ⅰ   Ⅱ   Ⅲ   Ⅳ   Ⅴ   Ⅵ   Ⅶ   Ⅷ   Ⅸ   Ⅹ   Ⅺ   Ⅻ   Ⅼ   Ⅽ   Ⅾ   Ⅿ</span><br><span class="line">ⅰ   ⅱ   ⅲ   ⅳ   ⅴ   ⅵ   ⅶ   ⅷ   ⅸ   ⅹ   ⅺ   ⅻ   ⅼ   ⅽ   ⅾ   ⅿ</span><br><span class="line">ↀ   ↁ   ↂ   Ↄ   ↄ   ↅ   ↆ   ↇ   ↈ   ↉   ↊   ↋</span><br></pre></td></tr></table></figure></li><li><p>isdecimal</p><ul><li><img src="/2019/09/23/Python字符串详解/d0a2e3f0.png" alt=" U+0660, ARABIC-INDIC DIGIT ZERO"></li><li><strong>十进制数字，也就是阿拉伯数字，包含全角和半角</strong></li><li>Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. </li><li>Formally a decimal character is a character in the Unicode General Category “Nd”.</li></ul></li><li><p>isdigit</p><ul><li>Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. </li><li>This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers.</li><li>Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.</li><li><strong>包含十进制字符和一些特殊处理的数字，不一定基于十进制数字</strong></li><li>经过特殊处理的如 ①，¹ 等</li></ul></li><li><p>isnumberic</p><ul><li><img src="/2019/09/23/Python字符串详解/48490a2e.png" alt=" U+2155, VULGAR FRACTION ONE FIFTH"></li><li>Numeric characters include digit characters, and all characters that have the Unicode numeric value property,</li><li>e.g. U+2155, VULGAR FRACTION ONE FIFTH. </li><li>Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.</li><li><strong>包含digit，和所有具有Unicode数值属性的字符</strong></li><li>具有Unicode数值属性的所有字符<h5 id="字符串的编码"><a href="#字符串的编码" class="headerlink" title="字符串的编码"></a>字符串的编码</h5></li></ul></li><li><p>Return an <strong>encoded version</strong> of the string <strong>as a bytes object</strong>. </p></li><li><p>Default encoding is ‘utf-8’. </p></li><li><p>errors may be given to set a different <strong>error handling scheme</strong>. The default for errors is ‘strict’, meaning that encoding errors raise a UnicodeError</p></li><li><p><strong>对字符串按照提供的编码格式进行编码，转成bytes</strong></p><h6 id="error-handling"><a href="#error-handling" class="headerlink" title="error handling"></a>error handling</h6></li><li><p><img src="/2019/09/23/Python字符串详解/5c181c38.png" alt="error_handling"></p></li></ul><h4 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h4><ul><li>Bytes objects are immutable sequences of single bytes.</li><li><strong>字节对象是单个字符的不可变序列</strong></li><li><strong>单个字符-【0，255】</strong></li><li><strong>字节</strong></li><li>一个byte = 8个bit = 2<strong>8 = **256</strong> </li><li><strong>ASCII 第一位表示正负标识，其余7为表示字符</strong></li><li>定义：<ul><li>bytes() <strong>转换成二进制表示</strong><ul><li><strong>包含汉字的必须使用bytes转换成二进制</strong></li><li>英文，数字 都转换成了 二进制</li><li>使用十六进制表示</li></ul></li><li>b<code>1</code>:表示字符串的二进制<ul><li><strong>字符串可以使用简单的ASCII表示</strong></li><li><img src="/2019/09/23/Python字符串详解/4f23c1f0.png" alt="是汉字的情况"></li></ul></li><li>在Python中<ul><li>字符串编码encode后<ul><li>中文 –》 十六进制</li><li>英文和数字(&lt;255): —&gt; b’英文/数字’</li></ul></li><li>解码<ul><li>b’0x*****’ —&gt;  中文</li><li>b’1’ —-》 ‘1’</li></ul></li></ul></li></ul></li><li><code>class bytes([source[, encoding[, errors]]])</code><ul><li>Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a b prefix is added:</li><li>字节和字符串的语法基本相同，不过前面添加了<code>b</code></li><li>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). </li><li>Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</li><li>字节只使用127个ASCII字符<blockquote><p>In addition to the literal forms, bytes objects can be created in a number of other ways:<br><strong>A zero-filled bytes object of a specified length</strong>: bytes(10)<br><strong>From an iterable of integers</strong>: bytes(range(20))<br>Copying existing binary data via the buffer protocol: bytes(obj)</p></blockquote></li><li><img src="/2019/09/23/Python字符串详解/fdb26710.png" alt="bytes类"></li><li><img src="/2019/09/23/Python字符串详解/3a987dab.png" alt="bytes的初始化"></li><li><a href="11.字符串的编码.py">bytes的使用</a><h5 id="utf-8-与-汉字"><a href="#utf-8-与-汉字" class="headerlink" title="utf-8 与 汉字"></a>utf-8 与 汉字</h5></li></ul></li><li>utf-8 使用三个字符表示汉字，其中1个表示结束，1个表示开始</li><li>gbk 使用两个字符表示汉字，没有结束符</li><li>不同的编码，对汉字表示不一致，所有解码和编码的编码格式必须一致，否则解码错误<h6 id="文件存储在硬盘和文件中存储的是二进制方式"><a href="#文件存储在硬盘和文件中存储的是二进制方式" class="headerlink" title="文件存储在硬盘和文件中存储的是二进制方式"></a>文件存储在硬盘和文件中存储的是二进制方式</h6><h6 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h6></li><li>str 字符串 编码成 二进制 <code>encode()</code></li><li>bytes 字节 解码 —》 字符串 <code>decode()</code></li><li>注意：<strong>编码格式一致</strong>,否则<strong>代码错误或者乱码</strong><ul><li><strong>主要是对 中文</strong></li><li><strong>英文的编码在任何字符集中都是一致的</strong><ul><li>字符集是在ASCII码的基础上发展的<br><img src="/2019/09/23/Python字符串详解/25935f82.png" alt="decode"><br><img src="/2019/09/23/Python字符串详解/dc268b51.png" alt="encode"></li></ul></li></ul></li><li>应用：<ul><li>爬虫抓取网页</li></ul></li></ul><h6 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h6><ul><li>Bytes() 的错误处理 机制  error handling</li><li>ignore  解码失败的情况下，强行解码</li><li>strics  默认的，报错 <code>UnicodeDecodeError</code></li></ul><h5 id="字符串的模板"><a href="#字符串的模板" class="headerlink" title="字符串的模板"></a>字符串的模板</h5><ul><li>字符串模板，做好模板，<strong>使用<code>$变量</code>等待传入数据</strong></li><li><strong>提供了更为简单的字符串替换</strong></li><li>Template String 使用了基于<strong>$变量</strong>的替换<ul><li>使用单个的<code>$</code></li><li><code>${identifier}</code>或则和<code>$identifier</code>:同样的作用，主要是区分占位符</li></ul></li><li>class string.Template(template) <ul><li>单个参数，即构造字符串</li></ul><ol><li>substitute(mapping, **kwds) <ul><li>执行模板替换，返回一个新的字符串</li><li>mapping：类似字典的对象，<strong>键值和模板占位符匹配</strong></li><li>也可以提供<strong>关键字参数</strong></li></ul></li><li>safe_substitute(mapping, **kwds) <ul><li>同上一个，稍微优化</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串详解&quot;&gt;&lt;a href=&quot;#字符串详解&quot; class=&quot;headerlink&quot; title=&quot;字符串详解&quot;&gt;&lt;/a&gt;字符串详解&lt;/h3&gt;&lt;h4 id=&quot;eval-和-evec&quot;&gt;&lt;a href=&quot;#eval-和-evec&quot; class=&quot;headerlink&quot; title=&quot;eval 和 evec&quot;&gt;&lt;/a&gt;eval 和 evec&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;eval：&lt;ul&gt;
&lt;li&gt;eval 语句用来计算存储在字符串中的&lt;strong&gt;有效表达式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;内置函数&lt;/li&gt;
&lt;li&gt;可以转化为实数,&lt;strong&gt;只能处理字符串形式的表达式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;常见的使用：&lt;code&gt;num = eval(input(&amp;quot;输入数据:&amp;quot;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The expression argument is parsed and evaluated as a Python expression &lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval(&amp;quot;2+2&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数是 “字符串”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;eval() arg 1 must be a string, bytes or code object&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将文本当作表达式使用&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础数据类型</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/23/Python基础数据类型/</id>
    <published>2019-09-23T07:17:46.000Z</published>
    <updated>2019-09-23T07:25:11.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><strong>零个或多个字符的有序集合</strong></li><li>属于 <strong>序列</strong><ul><li>可以进行序列操作，如[]</li><li>索引从0开始</li><li>for循环遍历<a id="more"></a>    <h5 id="enumrate-函数"><a href="#enumrate-函数" class="headerlink" title="enumrate() 函数"></a>enumrate() 函数</h5></li></ul></li><li><code>enumerate(iterable, start=0)</code> </li><li>Return an enumerate object. </li><li>iterable must be a sequence, an iterator, or some other object which supports iteration. </li><li>The <strong>next</strong>() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.</li><li>返回一个<strong>枚举对象</strong>，有元组组成</li><li>元组的元素是 <strong>可迭代对象的值和索引</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span><span class="params">(sequence, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h5><ol><li>字符串的截取<ul><li>str[start:stop:step]</li><li>不包含stop</li><li>step 默认1</li><li>[0:0:-1] <strong>反序</strong></li></ul></li><li>字符串索引<ul><li>正向索引：<strong>从0开始，从左到右</strong></li><li>反向索引：<strong>从-1开始，从右到左</strong></li></ul></li></ol><ul><li>字符串操作符<ul><li><ul><li>字符串拼接</li></ul></li><li><ul><li>字符串重复  <strong>后面接数字</strong></li></ul></li><li>in 成员元素符</li></ul></li><li>字符串的循环<ol><li>in操作符，使用字符遍历</li><li>索引，使用索引遍历</li></ol><ul><li>主要用途：<strong>加密和解密</strong></li></ul></li></ul><h4 id="字符串本质"><a href="#字符串本质" class="headerlink" title="字符串本质"></a>字符串本质</h4><ul><li><strong>字符串是零个或多个字符和有序集合</strong></li><li><strong>字符串内部是不可更改的</strong><ul><li><strong>没有对字符串中单个字符赋值的操作</strong></li><li>TypeError: ‘str’ object does not support item assignment</li><li>字符串是一个整体</li></ul></li><li><strong>字符串属于不可变数据类型</strong></li><li>可以赋值，但是是<strong>指向 新的字符串</strong></li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>列表</li><li>一组元素的集合，使用[]包括，且元素之间使用<code>,</code>隔开</li><li>属于 <strong>序列</strong></li></ul><h5 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h5><ol><li><p>for循环遍历</p><ol><li>元素循环  for ch  in list</li><li>索引索引 range(len(list) - 1)</li></ol></li><li><p>len()</p><ul><li>统计list的元组个数</li></ul></li><li><p>append()</p><ul><li>列表添加元素，在末端位置</li><li><strong>添加的是一个元素</strong><ul><li>参数是列表的话，当作一个元素</li></ul></li><li>和 + 区别</li></ul></li><li><p>1 extend()</p><ul><li>列表末尾添加元素</li><li>参数是可迭代对象，添加元素</li><li><a href="4.列表的基本操作.py">extend 和 append</a></li></ul></li><li><p>index()</p><ul><li>返回元素的索引位置，</li><li>如果没有的话，报错 <code>ValueError: -3 is not in list</code></li></ul></li><li><p>切片</p><ul><li>[::-1]  反序</li><li><strong>需要赋值给其他变量</strong></li><li>和 字符串一致</li></ul></li><li><ul><li><ul><li>列表的拼接</li><li><strong>列表各个元素</strong>的拼接</li></ul></li></ul></li><li><p>*</p><ul><li>复制两次</li><li>使用的是<strong>列表的元素</strong></li></ul></li></ol><h4 id="列表的本质"><a href="#列表的本质" class="headerlink" title="列表的本质"></a>列表的本质</h4><ul><li><strong>列表属于可变数据类型</strong></li><li><strong>列表的元素可以变化</strong></li><li><strong>元素改变之后列表的地址没有变化</strong><h5 id="list-容量"><a href="#list-容量" class="headerlink" title="list 容量"></a>list 容量</h5></li><li><strong>可以用到内存的尽头</strong></li></ul><h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h4><ul><li>不被修改的list，用<code>()</code>定义</li><li>属于<strong>序列</strong></li><li>循环方式一致<ul><li>循环的作用<strong>只能输出打印</strong></li></ul></li></ul><h5 id="不可变数据类型"><a href="#不可变数据类型" class="headerlink" title="不可变数据类型"></a>不可变数据类型</h5><ul><li><strong>元组的元素不能修改，属于常量</strong></li></ul><h5 id="元组的特例"><a href="#元组的特例" class="headerlink" title="元组的特例"></a>元组的特例</h5><ul><li><strong>创建单元素元组的时候，必须在元素后面加逗号</strong></li><li>否则的话，创建的是元素对象，而不是元组</li><li><a href="7.元组的特点.py">单元素</a></li></ul><h4 id="set-集合操作"><a href="#set-集合操作" class="headerlink" title="set 集合操作"></a>set 集合操作</h4><ul><li><p><strong>无序的不重合元素序列</strong></p></li><li><p>使用set()或者<code>{}</code>创建集合</p></li><li><p><strong>set不支持序列index操作，没有下标</strong></p></li><li><p>但是<strong>创建一个空集合必须用 <code>set()</code>而不是 <code>{ }</code></strong>，因为 { } 是用来创建一个空字典</p></li><li><p><code>frozenset()</code> 返回一个<strong>冻结的集合</strong>，<strong>冻结后集合不能再添加或删除任何元素</strong></p></li><li><p>循环–<strong>元素循环</strong></p></li><li><p>常见用途</p><ul><li>成员关系测试<ul><li>in</li><li>not in </li></ul></li><li>删除重复元素<ul><li><ul><li>差集</li></ul></li><li>| 并集</li><li>&amp; 交集</li><li>^ 不同时存在的元素</li></ul></li></ul></li><li><p>set无序排序且不重复，是可变的，有add（），remove（）等方法。既然是可变的，所以它不存在哈希值。基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交集), difference(差集)和sysmmetric difference(对称差集)等数学运算.<br>sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, 或其它类序列的操作。<br>frozenset是冻结的集合，它是不可变的，存在哈希值，好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法。</p></li></ul><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul><li><p>不重复的键值对的无序集合</p><ul><li><strong>会覆盖掉的</strong>   </li></ul></li><li><p><code>key:value</code> 模型，<strong>键值对之间用逗号隔开</strong></p></li><li><p>set的升级版</p></li><li><p>使用<code>{}</code>定义</p></li><li><p><strong>值可以取任何数据类型，但键必须是不可变的</strong></p></li><li><p><strong>key不能重复，value可以重复</strong></p><h5 id="字典的方法"><a href="#字典的方法" class="headerlink" title="字典的方法"></a>字典的方法</h5></li></ul><ol><li>items()<ul><li>返回(key,value)列表</li></ul></li><li>keys()<ul><li>返回keys列表</li></ul></li><li>values()<ul><li>返回values列表<h5 id="字典的循环"><a href="#字典的循环" class="headerlink" title="字典的循环"></a>字典的循环</h5></li></ul></li></ol><ul><li>for循环只能使用 元素遍历循环<ol><li>遍历 key  .keys()</li><li>遍历 value   .values()</li><li>遍历 键值对   .items()</li></ol></li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><ol><li>in</li><li>not in</li></ol><ul><li>对于list和tuple 是否存在</li><li>对于dict，<strong>判断键是否存在于字典中</strong></li></ul><h5 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h5><ul><li>在for循环中，in操作符表示<strong>遍历</strong></li></ul><h4 id="构造表达式"><a href="#构造表达式" class="headerlink" title="构造表达式"></a>构造表达式</h4><ul><li><code>mylist 变量 = [x 返回值或者元素 for x in range(10) 元素构造表达式  ]</code></li><li>列表构造表达式</li><li>字典构造表达式</li></ul><h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><ul><li><img src="/2019/09/23/Python基础数据类型/a27a0e2b.png" alt="数据类型转换函数"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础数据类型&quot;&gt;&lt;a href=&quot;#基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;基础数据类型&quot;&gt;&lt;/a&gt;基础数据类型&lt;/h3&gt;&lt;h4 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;零个或多个字符的有序集合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;属于 &lt;strong&gt;序列&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;可以进行序列操作，如[]&lt;/li&gt;
&lt;li&gt;索引从0开始&lt;/li&gt;
&lt;li&gt;for循环遍历&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/23/Python函数/</id>
    <published>2019-09-23T07:14:30.000Z</published>
    <updated>2019-09-23T07:17:04.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>将<strong>代码块**</strong>封装<strong>到一个</strong>def定义的函数名**中</li><li>def 关键字 用于定义函数名</li><li>之后使用函数名可以<strong>多次使用代码块</strong>，<strong>不需要重写代码块</strong></li><li>简化代码编写，<strong>代码块反复利用</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数体</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">函数名(实际参数列表)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><img src="/2019/09/23/Python函数/af01568b.png" alt="函数定义，调用"></li></ul><h5 id="函数抽象和逐步求精"><a href="#函数抽象和逐步求精" class="headerlink" title="函数抽象和逐步求精"></a>函数抽象和逐步求精</h5><ul><li>函数抽象：将<strong>函数的使用</strong>和<strong>函数的实现</strong>分开实现</li></ul><h5 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h5><ol><li>没有参数，没有返回值<ul><li>参数列表为空</li><li>没有 return语句</li><li>一般用于打印 <code>字符串</code></li></ul></li><li>有参数，没有返回值<ul><li>参数需要传入</li><li>没有 return 语句</li><li>常用于 打印 <code>变量内容</code></li></ul></li><li>没有参数，有返回值<ul><li>没有参数传入</li><li>有 return 语句</li><li>常用于 返回固定的值或者随机数</li><li>需要变量接受返回值</li></ul></li><li>有参数，有返回值<ul><li>常见的</li><li>有参数传入，有返回值</li></ul></li></ol><h4 id="函数的执行顺序"><a href="#函数的执行顺序" class="headerlink" title="函数的执行顺序"></a>函数的执行顺序</h4><ul><li>顺序执行</li><li>依次执行完成，再执行下一个<h5 id="函数的复合调用过程"><a href="#函数的复合调用过程" class="headerlink" title="函数的复合调用过程"></a>函数的复合调用过程</h5></li><li>瀑布执行</li><li>遇到函数调用，就执行函数，<strong>当执行到return或者函数体完成时返回到主函数中</strong><ul><li>继续主函数的执行</li></ul></li><li><strong>函数调用必须等待函数返回之后，才能执行下一步</strong></li><li><img src="/2019/09/23/Python函数/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="函数调用过程">   </li></ul><h4 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h4><ul><li>函数的本质是一个<strong>地址</strong></li><li><strong>函数名是变量，存储一段代码的地址</strong></li><li>所以可以将函数名赋值给另一个变量</li><li>但是函数后面接参数的时候，赋值给另一个变量，是将函数的返回数据赋值给变量</li><li>直接<code>print(函数名)</code>: 可以看到<strong>函数名的具体内容</strong></li><li><strong>修改地址可以实现不同的行为</strong></li></ul><h4 id="函数变量的用途"><a href="#函数变量的用途" class="headerlink" title="函数变量的用途"></a>函数变量的用途</h4><ul><li>接口：函数的<strong>对外</strong>，<strong>变量列表</strong>，不变</li><li>业务需求：是常常变化的， </li><li><strong>业务需求发生变化</strong>，但是<strong>代码内容不变</strong></li></ul><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li><strong>函数当作另一个函数的参数</strong></li><li>是修改其他函数的功能的函数</li><li>封装一个函数，并且用这样或者那样的方式来修改它的行为</li><li>用于拓展原来函数功能的一种函数，目的是在不改变原函数名(或类名)的情况下，给函数增加新的功能。 这个函数的特殊之处在于它的<strong>返回值也是一个函数</strong>，这个函数是内嵌“原“”函数的函数。</li></ul><h5 id="None"><a href="#None" class="headerlink" title="None"></a>None</h5><ul><li><strong>函数如果没有明确返回值，函数默认返回None</strong></li></ul><ol><li>没有return语句，默认返回None<ul><li>如果print函数或者有变量接受，结果是None</li></ul></li><li>有return语句，但是return 后面没有任何数据，返回None </li></ol><h4 id="实际参数-和-形式参数"><a href="#实际参数-和-形式参数" class="headerlink" title="实际参数 和 形式参数"></a>实际参数 和 形式参数</h4><ul><li>实参： <strong>函数调用时传入的参数</strong></li><li>形参： <strong>函数定义时参数列表中的参数，也就是在函数体中没有赋值直接使用的参数</strong></li><li>调用函数时，必须正确传递参数<ul><li>保持 <strong>实参与形参一一对应</strong></li></ul></li></ul><h5 id="默认参数，位置参数-和-关键字参数"><a href="#默认参数，位置参数-和-关键字参数" class="headerlink" title="默认参数，位置参数 和 关键字参数"></a>默认参数，位置参数 和 关键字参数</h5><ul><li>默认参数：函数定义时，<strong>在参数列表中已经赋值</strong><ul><li>当函数调用时，没有传入数值，使用默认参数</li><li>当函数调用时，传入了数值，使用传入的数值</li></ul></li><li>位置参数：函数调用传入实参，和形参<strong>按照位置一一对应</strong><ul><li>从左向右，依次填充</li></ul></li><li>关键字参数: 函数调用时，使用<code>形参=实参</code>的方式传递数据<ul><li>也称为：名称参数</li><li><strong>顺序可以混乱</strong></li><li><strong>位置参数可以和名称参数混用</strong><ul><li>必须是 先位置参数，再名称参数</li><li>print(“zhaolong”,end=” “)</li></ul></li></ul></li></ul><h5 id="参数副本机制（不可变数据类型）"><a href="#参数副本机制（不可变数据类型）" class="headerlink" title="参数副本机制（不可变数据类型）"></a>参数副本机制（不可变数据类型）</h5><ul><li>传递参数时，<strong>把实参拷贝给形参，把地址传递给形参</strong><ul><li>可变数据类型：列表，字典，元组<ul><li>会改变原来的值</li></ul></li><li>不可变数据类型：数值，字符串 <ul><li>不会改变原来的值</li></ul></li></ul></li></ul><h5 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h5><ul><li>return x,y,z… </li><li>函数返回多个参数，<strong>以元组的形式返回</strong></li><li>需要<strong>使用对应的变量</strong>接受返回数据</li></ul><h5 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h5><ul><li><strong>全局变量</strong>：函数外部定义的, 作用范围<strong>在程序内部</strong></li><li><strong>局部变量</strong>：函数内部定义的，作用在函数内部</li><li>函数内部的变量会首先查询局部变量，如果没有的话，才会使用同名的全局变量</li></ul><h6 id="引用全局变量-global"><a href="#引用全局变量-global" class="headerlink" title="引用全局变量  global"></a>引用全局变量  global</h6><ul><li>在函数内部，引用全局变量</li><li>使用<code>global</code>关键字<strong>申明使用全局变量</strong><ul><li>在函数内部使用的变量是全局变量</li><li>对变量的操作就是对全局变量的操作</li></ul></li></ul><h5 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h5><ul><li>函数可以<strong>嵌套定义</strong></li><li>使用内层的函数<ul><li><strong>必须在外层函数中明确调用内层函数</strong></li><li><a href="19.函数的嵌套.py">函数嵌套</a></li></ul></li><li>同名变量<ul><li>内层会覆盖外层变量，不同的变量，不同的地址</li><li><code>nonlocal 变量</code>: 不新建新的变量，使用外层的局部变量</li></ul></li></ul><h5 id="nonlocal-用于嵌套函数中-使用外层的局部变量"><a href="#nonlocal-用于嵌套函数中-使用外层的局部变量" class="headerlink" title="nonlocal 用于嵌套函数中 使用外层的局部变量"></a>nonlocal 用于嵌套函数中 使用外层的局部变量</h5><ul><li><strong>内层函数使用外层函数的局部变量，使用<code>nonlocal</code>关键字</strong><ul><li><code>nonlocal 外层同名变量</code></li><li><strong>不新建本地变量，引用外层局部变量</strong></li></ul></li></ul><h5 id="函数的两种类型"><a href="#函数的两种类型" class="headerlink" title="函数的两种类型"></a>函数的两种类型</h5><ol><li>内置函数 builtin_function_method</li><li>自定义函数 function</li></ol><h5 id="函数的执行顺序-1"><a href="#函数的执行顺序-1" class="headerlink" title="函数的执行顺序"></a>函数的执行顺序</h5><ol><li>函数执行结束后，之后的代码才可以执行</li><li>自上而下，顺序执行</li></ol><h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><ul><li>return <strong>之后的语句不会再被执行</strong></li><li>return 表示函数<strong>到此结束</strong></li></ul><h5 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h5><ul><li><p>python3的新特性</p></li><li><p>lambda 关键字</p></li><li><p>lambda <strong>参数</strong>a,b: <strong>返回值</strong> a+b</p></li><li><p>不需要使用def</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class 'function'&gt;</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x0000023115C09288&gt;</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ol><li>lambda x:print(x):是一个匿名函数</li><li><strong>调用的时候需要给函数加（）</strong>，<strong>是一个整体</strong>，或则赋值给一个变量</li></ol><h5 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h5><ul><li>定义函数时，<strong>参数未知</strong></li><li>使用 <code>*num</code></li><li><code>*num</code>表示<strong>一个序列</strong>，<strong>传入多少数据，接受多个数据</strong></li><li><strong>函数调用时，参数之间使用逗号分隔</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;代码块**&lt;/strong&gt;封装&lt;strong&gt;到一个&lt;/strong&gt;def定义的函数名**中&lt;/li&gt;
&lt;li&gt;def 关键字 用于定义函数名&lt;/li&gt;
&lt;li&gt;之后使用函数名可以&lt;strong&gt;多次使用代码块&lt;/strong&gt;，&lt;strong&gt;不需要重写代码块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;简化代码编写，&lt;strong&gt;代码块反复利用&lt;/strong&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; 函数名&lt;span class=&quot;params&quot;&gt;(参数列表)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    函数体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#调用函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;函数名(实际参数列表)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python循环-for</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%BE%AA%E7%8E%AF-for/"/>
    <id>http://yoursite.com/2019/09/23/Python循环-for/</id>
    <published>2019-09-23T07:10:27.000Z</published>
    <updated>2019-09-23T07:12:52.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><ul><li>Python中的for循环通过一个<strong>序列</strong>中的<strong>每个值</strong>来进行<strong>迭代</strong></li><li>知道循环次数的</li><li><strong>计数器控制的循环</strong></li><li>不需要使用变量来控制循环</li><li>迭代环境，使用的是 <strong>可迭代的对象</strong><ul><li>列表</li><li>元组</li><li>字典</li><li>集合</li><li>字符串</li></ul></li><li>for循环<strong>处理速度稍微快点</strong><ul><li>主要是<strong>计数器参与运算的</strong>，不需要在循环体中再次编写</li></ul></li><li>for 循环的参数是<strong>正整数</strong>–计数器<a id="more"></a><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5></li><li><img src="/2019/09/23/Python循环-for/ff0ac7b8.png" alt="Range"></li><li>an immutable sequence of numbers 不可变的数字序列，用于For循环中</li><li>两种用法<ul><li><code>class range(stop)</code> </li><li><code>class range(start, stop[, step])</code></li></ul></li><li>函数的参数必须是<strong>整数</strong></li><li>省略step参数，则默认为1.省略start参数，默认为0.如果step为零，则引发<code>ValueError</code></li><li>不包含 stop</li><li>For a positive step, the contents of a range r are determined by the formula <code>r[i] = start + step*i where i &gt;= 0 and r[i] &lt; stop</code>.</li><li>For a negative step, the contents of the range are still determined by the formula <code>r[i] = start + step*i</code>, but the constraints are <code>i &gt;= 0 and r[i] &gt; stop</code>.</li><li>负指数，被解释为从正指数确定的序列末尾开始索引</li><li>负方向：表示的是从start开始，每次减去abs(step)的数值,而且 start &gt; stop</li><li>本质上，是从start开始到stop-1截至，按照step取值<ul><li>当step为正数，start&lt;stop,<code>做加法</code></li><li>当step为负数，start&gt;stop，<code>做减法</code></li><li>start != stop</li><li>i!= 0  </li></ul></li></ul><h5 id="else"><a href="#else" class="headerlink" title="else"></a>else</h5><ul><li>for - else：<ul><li><strong>恰好即将跳出循环</strong></li><li>else 的条件是 <strong>最后一个条件</strong></li><li>结合for循环，会将<strong>最后一个值</strong>执行for语句和else语句<strong>两次</strong></li><li><img src="/2019/09/23/Python循环-for/bd105252.png" alt="for-else"></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># for仅仅使用整数</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(i)  <span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="for循环与while循环"><a href="#for循环与while循环" class="headerlink" title="for循环与while循环"></a>for循环与while循环</h5><ul><li>任何for循环都可以转化为while循环</li><li>但是 while循环不一定能转化成for循环<ul><li>while 循环可以处理<strong>实数</strong></li><li>while 循环可以处理<strong>死循环</strong></li></ul></li></ul><h5 id="for-循环的嵌套"><a href="#for-循环的嵌套" class="headerlink" title="for 循环的嵌套"></a>for 循环的嵌套</h5><ul><li>嵌套循环可能会花费很长的时间来允许</li><li>用途<ul><li>显示<strong>列表</strong></li><li>平面</li></ul></li></ul><h5 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h5><ul><li>break 中断循环，直接跳出循环<ul><li>不会执行else语句</li><li><strong>结束多余</strong>的循环</li></ul></li><li>continue <strong>结束本次循环</strong>，继续下一次循环<ul><li>忽略continue之后的代码，返回循环头部继续一下次循环</li><li>主要起到 <strong>筛选作用</strong></li></ul></li><li>break 和 continue <strong>必须搭配 if</strong> 进行判断</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="循环的三种方式"><a href="#循环的三种方式" class="headerlink" title="循环的三种方式"></a>循环的三种方式</h5><ol><li>while</li><li>for</li><li>死循环+break</li></ol><h5 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h5><ul><li>break</li><li>continue</li></ul><h5 id="else-1"><a href="#else-1" class="headerlink" title="else"></a>else</h5><ul><li>for-else：<ul><li>即将跳出循环</li><li>对最后一个计数器<strong>再次处理</strong></li></ul></li><li>while-else:<ul><li>对 <strong>临界值</strong> 进行处理</li></ul></li></ul><h5 id="while-风格"><a href="#while-风格" class="headerlink" title="while 风格"></a>while 风格</h5><ul><li>设定循环次数，包含了<strong>循环终止条件</strong></li><li><strong>变量值发生变化</strong></li><li><code>while Ture if break</code></li><li>常见错误：忘记自增或则自减</li><li>可以处理<strong>浮点数</strong><ul><li>num - 数值 &lt; 0.000001</li></ul></li></ul><h5 id="for-风格"><a href="#for-风格" class="headerlink" title="for 风格"></a>for 风格</h5><ul><li>循环条件  <strong>计数器 整数</strong><ul><li>常使用 range <ul><li>range(100)</li><li>range(1,100,1)</li><li>range(100,1,-10)</li></ul></li><li>不包含第二个值</li><li>默认步长  1</li><li><strong>步长不能为0</strong> -&gt; for不能实现死循环</li></ul></li></ul><h5 id="时间统计"><a href="#时间统计" class="headerlink" title="时间统计"></a>时间统计</h5><ul><li>time.time() 返回当前时间，以<strong>秒</strong>为单位</li><li>做减法可以得到<strong>时间差</strong></li><li>time.sleep(5)<ul><li>暂停5秒</li></ul></li></ul><h5 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h5><ol><li>添加<strong>临时变量</strong>，交换变量</li><li>对称赋值 <code>a,b = b,a</code><ul><li>先计算=号右边的表达式</li><li>交换数据</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;&lt;/a&gt;for循环&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Python中的for循环通过一个&lt;strong&gt;序列&lt;/strong&gt;中的&lt;strong&gt;每个值&lt;/strong&gt;来进行&lt;strong&gt;迭代&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;知道循环次数的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计数器控制的循环&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不需要使用变量来控制循环&lt;/li&gt;
&lt;li&gt;迭代环境，使用的是 &lt;strong&gt;可迭代的对象&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;列表&lt;/li&gt;
&lt;li&gt;元组&lt;/li&gt;
&lt;li&gt;字典&lt;/li&gt;
&lt;li&gt;集合&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for循环&lt;strong&gt;处理速度稍微快点&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;主要是&lt;strong&gt;计数器参与运算的&lt;/strong&gt;，不需要在循环体中再次编写&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for 循环的参数是&lt;strong&gt;正整数&lt;/strong&gt;–计数器&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python循环-while</title>
    <link href="http://yoursite.com/2019/09/23/Python%E5%BE%AA%E7%8E%AF-while/"/>
    <id>http://yoursite.com/2019/09/23/Python循环-while/</id>
    <published>2019-09-23T06:58:06.000Z</published>
    <updated>2019-09-23T07:09:40.704Z</updated>
    
    <content type="html"><![CDATA[<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><ul><li>条件表达式的<strong>结果或本身</strong>都被计算成 <strong>布尔型</strong></li><li>当<strong>条件不满足</strong>的时候，<strong>循环结束</strong></li><li>如：None , <code>&quot;&quot;</code>，0 都被<strong>转化</strong>成 False</li><li>True 继续循环<ul><li>1，” “, 1,-1,True,1.234</li></ul></li><li>False 推出循环<ul><li>None,0,””,False<a id="more"></a><h5 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h5></li></ul></li><li><strong>条件一直为True</strong>，循环会一直执行下去</li><li><strong>条件表达式是常量</strong></li></ul><h5 id="有限循环"><a href="#有限循环" class="headerlink" title="有限循环"></a>有限循环</h5><ul><li><strong>条件在循环过程中会发生改变</strong>，结束程序运行</li><li><strong>条件使用变量</strong><ul><li>且在循环过程中 <strong>变量的值发生变化</strong></li></ul></li></ul><h6 id="else"><a href="#else" class="headerlink" title="else"></a>else</h6><ul><li>while-else: <strong>正常退出循环的时候会执行的else语句</strong>，<strong>不满足条件的时候执行</strong><ul><li>包含 条件不满足退出</li><li>包含 continue语句</li><li>包含 <strong>刚开始条件就不满足</strong>1，直接执行else语句</li><li><strong>break</strong>跳出循环，不执行else语句</li></ul></li><li>else: 是条件表达式的<strong>临界点</strong>，处理临界点的</li></ul><h5 id="浮点数的科学表达式"><a href="#浮点数的科学表达式" class="headerlink" title="浮点数的科学表达式"></a>浮点数的科学表达式</h5><ul><li>正数： 8.16e12</li><li>负数： 8.16e-12</li><li>浮点数的<strong>尾数不确定性</strong>导致在循环中不能直接处理，需要<strong>通过和0做减法</strong>，<strong>阈值筛选</strong>来使用，否则容易出现你BUG</li><li>使用查询来判断浮点数<ul><li>num - num1&lt; 0.00000001</li></ul></li></ul><h4 id="连续的关系运算符"><a href="#连续的关系运算符" class="headerlink" title="连续的关系运算符"></a>连续的关系运算符</h4><ul><li>3 &gt; 2 &gt; 1 —-&gt; <code>3 &gt;2 and 2 &gt; 1</code></li><li>and 表达式</li><li>隐藏的and表达式</li></ul><h5 id="if-else-三元表达式"><a href="#if-else-三元表达式" class="headerlink" title="if -else 三元表达式"></a>if -else 三元表达式</h5><ul><li>值1 if 条件表达式 else 值2</li><li>True 值=值1</li><li>False 值= 值2</li></ul><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><ul><li><img src="/2019/09/23/Python循环-while/1cf613aa.png" alt="运算符优先级"></li></ul><h5 id="循环穷举-编程思想"><a href="#循环穷举-编程思想" class="headerlink" title="循环穷举-编程思想"></a>循环穷举-编程思想</h5><ul><li>用于计算 10x+20Y = 10000</li><li>确定x的取值范围，做循环，计算 对于的Y值，如果Y值复合条件，就输出</li></ul><h4 id="if-表达式的的编程思想"><a href="#if-表达式的的编程思想" class="headerlink" title="if-表达式的的编程思想"></a>if-表达式的的编程思想</h4><ul><li>无限划分，遍历每种情况</li></ul><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><ol><li>数据</li><li>指令</li></ol><h5 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h5><ul><li>需要使用 win32 包<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client  <span class="comment"># 系统客户端的包</span></span><br><span class="line">speaker = win32com.client.Dispatch(<span class="string">"SAPI.SPVOICE"</span>)  <span class="comment"># 系统接口</span></span><br><span class="line">speaker.Speak(<span class="string">"陈钰琪，1992年7月29日出生于四川省成都市"</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="输入输出的重定向"><a href="#输入输出的重定向" class="headerlink" title="输入输出的重定向"></a>输入输出的重定向</h5><ul><li>使用符号</li><li><code>&gt;</code>  写入文本，覆盖 </li><li><code>&gt;&gt;</code>  写入文本，追加</li><li><code>&lt;</code> 从文件中读取</li><li><strong>可以连接配合使用</strong></li></ul><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><ul><li>空对象 。</li><li>属于 NoneType类型</li><li>在条件表达式中会自动转化为 False</li></ul><h4 id="嵌套逻辑"><a href="#嵌套逻辑" class="headerlink" title="嵌套逻辑"></a>嵌套逻辑</h4><ul><li>特别注意： 层级结构 空格或Tab不能混用</li></ul><ol><li>不是  if- elif- elif-else</li><li>是  if - if - if</li><li>条件的<strong>等级是并列,且满足其中一个条件</strong>的情况下，使用if - elif 语句<ul><li>条件的<strong>顺序</strong>是相连的，非顺序，需要添加区域条件</li><li><strong>隐含条件</strong></li><li>对嵌套的if-if 可以<strong>简化</strong></li></ul></li><li>条件的的<strong>等级是承接，必须全部满足的</strong>的情况下，使用 if-else 语句</li></ol><h4 id="运算符的优先级和结合性"><a href="#运算符的优先级和结合性" class="headerlink" title="运算符的优先级和结合性"></a>运算符的优先级和结合性</h4><ul><li>运算符的<strong>优先级</strong>和<strong>结合方向</strong>决定了<strong>运算符的计算顺序</strong></li><li>结合性：同意优先级下表达式的计算顺序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;while循环&quot;&gt;&lt;a href=&quot;#while循环&quot; class=&quot;headerlink&quot; title=&quot;while循环&quot;&gt;&lt;/a&gt;while循环&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;条件表达式的&lt;strong&gt;结果或本身&lt;/strong&gt;都被计算成 &lt;strong&gt;布尔型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;条件不满足&lt;/strong&gt;的时候，&lt;strong&gt;循环结束&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如：None , &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;，0 都被&lt;strong&gt;转化&lt;/strong&gt;成 False&lt;/li&gt;
&lt;li&gt;True 继续循环&lt;ul&gt;
&lt;li&gt;1，” “, 1,-1,True,1.234&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;False 推出循环&lt;ul&gt;
&lt;li&gt;None,0,””,False&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
