<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python进程]]></title>
    <url>%2F2019%2F10%2F10%2FPython%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程进阶 Python的线程并发运行实际是伪并发 进程大部分时间处于等待状态 对时间进行详细区分，一小段一小段时间的来回切换 GIL Global Interpreter Local 全局解释器锁， 数据安全 每个CPU在同一时间只能执行一个线程 单核CPu下的多线程其实都只是并发，不是并行 并行：两个或者多个事件在同一时刻发生 并发：两个或者多个事件在同一时间间隔内发生 Python多线程 获取GIL 执行代码知道sleep或者Python虚拟机将其挂起 释放GIL 线程想要执行，必须先拿到GIL，可以把GIL看做“通行证”，在一个Python进程中，GIL只有一个，拿不到通行证，就不允许进入CPU执行 GIL Python2.x中，GIL的释放逻辑是当前线程遇到IO操作或者ticks计数达到100进行释放 每次释放GIL锁，线程进行锁竞争，切换线程，会消耗资源 ticks Python的一个计数，专门作用于GIL，每次释放后归零 可以通过 sys.setcheakinterval调整 由于GIL锁的存在，Python里的一个线程永远只能同时执行一个线程 多核CPU上，Python的多线程效率不高 Python3.x 中，GIL不需要ticks计数，改为使用计时器*执行时间到达阈值后，自动释放GIL* 对CPU密集型程序更加友好 但是任然没有解决GIL导致同一时间只能执行一个线程的问题 分类讨论 CPU密集型代码： 各种循环，计数等 计算，深度学习，科学计算 计算工作多，ticks计数很快达到阈值，然后触发GIL释放与再竞争 Python下的多线程对CPU密集型代码不友好 IO密集型代码 文件处理，爬虫等 网络下载，网络等待 多线程可以有效的提升效率（单线程下有IO操作会进行IO等待，造成不必要的时间浪费） 开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU资源 Python的多线程对IO密集型代码比较友好 Python下想要充分利用多核CPU，就用多进程 每个进程有各自独立的GIL，互不干扰 多进程的执行效率由于多线程 多核下，想要做并行提起效率，比较通用的方法是 使用多进程，能够有效提高执行效率 多进程 完成多任务fork() 创建子进程 注意： 只能在 Unix/Linux/Mac上运行，window上不可以 当程序执行o.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中 唯一调用一次返回两次的函数，因操作系统将当前的进程（父进程）复制了一份新的进程（子进程），然后分别在父进程和子进程内返回 子进程永远返回0 父进程则返回子进程的PID 这意味着每个子进程的创建都会在父进程中留下标记PID（子进程身份信息），当子进程溯源其父进程时，通过getppid()就可以找到父进程的PID 一个父进程可以fork多个子进程，父进程需要记录每个子进程的ID，而子进程只要通过getppid就可以等到父进程的信息 创建子进程 会拷贝 fork()之后的所有代码 两份代码独立运行 当拷贝的代码属于父进程时，PID的值是 子进程的PID 当拷贝的代码属于子进程时，PID的值是0 根据返回的值不同，在不同的进程中运行不同的代码 父进程一般先执行，差别不大 全局变量 全局变量也会被拷贝，不共享 多次fork getpid(),getppid() multiprocessing os.fock() 只能运行在Unix系统上 multiprocessing 模块 是 跨平台的多进程模块 multiprocessing 提供Process类代表进程对象 创建子进程时，需要传入执行函数和函数的参数元祖，类似 threading.Thread 创建一个Process实例 用start()方法启动 join() 等待字进程结束后，继续执行 否则 父进程继续执行结束 进程共享 进程间不可以用全局变量共享数据 全局变量会被拷贝 队列可以实现进程共享 两个进程之间可以共享 虽然id值不一致 queue 拷贝了一次 只有一端可以压入数据 单向的结构 特定的变量 num = multiprocessing.Value(“d”, 0.0) 可以在多个线程之间共享 num = multiprocessing.Array(“i”, [1, 2, 3, 4, 5, 6]) 列表和字典 123with multiprocessing.Manager() as MG: mydict = MG.dict() mylist = MG.list(range(5)) 进程通信 管道 pipe 进程间的通信 管道两边开头，一端send，另一端recv 一端发送消息，一端接受消息 队列 单向通信的结构进程同步 Rlock 多进程，乱序，并发执行 多进程+Rlock，乱序，但是挨个执行]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python线程]]></title>
    <url>%2F2019%2F10%2F10%2FPython%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程 thread 是操作系统能够进行运算调度的最小单位。 它被包含在进程之中，是进程中的实际运作单位。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 线程是独立调度和分派的基本单位。 线程可以为操作系统内核调度的内核线程，如Win32线程； 由用户进程自行调度的用户线程，如Linux平台的POSIX Thread； 或者由内核与用户进程，如Windows 7的线程，进行混合调度 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。 但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage） 多线程 多线程可以充分利用计算机资源，多线程并发 主线程和次线程 win7上程序是进程 进程由线程组成，分为主线程和次线程 主线程：主要的运行线程，主线程结束，进程也结束 控制着进程的生命周期 次线程：次线程结束，但是进程依然运行 单线程和多线程 单线程所有代码顺序执行 多线程可以加速代码运行线程冲突 同时访问一个资源，会出现线程冲突 多个进程竞争访问一个资源 多个进程对资源进行修改 不会报错，但是结果不正确线程 join(timeout=None) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs. 等待线程终止 t.join 线程顺序执行 主程序等待线程执行完成之后，在启动另一个线程 进程启动，马上，等待结束 存在线程阻塞 t.join, 但是t是线程列表中的元素 主线程等待所有线程执行完成之后，结束进程 所有线程乱序执行，不会出现阻塞的情况 等待所有的线程全部结束 所有进程全部启动，等待结束锁 lock 在一段时间之内，只有一个线程可以操作变量 互斥量 Lock类 threading.Locak() acquire 锁住 参数 1 表示 独占 release 释放 注意 一定要释放，否则线程一直等待死锁 锁使用不当造成的 多个锁的情况下，锁释放不及时造成 多个线程使用多个锁，但是都不释放Rlock Reentrant Lock 可重入锁 单个锁，被多次使用，但是没有及时释放 一个线程对一个资源反复加锁，线程卡住 lock 的栈 后进先出 Rlock 指lock栈结构，避免单线程死锁 A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.创建线程的三种风格 函数 使用比较简答 但是适合简单操作 使用_thread 类的继承 适合比较复杂的操作 使用threading 类的构造函数 theading.Thead(target=函数名,args=(参数列表)).start()限定线程的数量 由于服务器内存有限，必须限制线程的使用####### 通过信号量限制 threading.Semaphore(2) 限制同时线程的最大数量是2 并发线程数量####### 锁定线程数量 threading.Barrier(2) 必须凑够2个线程才能一起执行,其他线程不会执行 线程通信 线程有顺序 事件 set() 触发事件 wait 等待set信号 clean 重置线程 condition Lock 和 event 的综合体，除基本的锁外，还提供yield功能 既解决通信又解决同步 cond = threading.Condition() with conda: 使用条件变量 锁的变换 先执行的线程将conda锁定 另一个线程处于等待状态 conda.wait() # 等待conda 资源释放 线程变为等待状态 另一个线程处理锁定状态 接收到信号之后，运行之后的代码，到下一次wait位置停止 conda.notify() # conda发送信号 发送通知 线程接受通知，锁定执行 另一个线程处理等待状态 只能发送信号，不能让线程等待，只能告诉wait的状态 注意： 锁会自动过度 生产者和消费者 生产者 多个 消费者 多个 队列 资源 冲突 线程池 多个线程 批量的管理，驾驭 前提:假定线程之间没有冲突 import threadpool 构造线程队列请求 makeRequests 将线程请求压入线程池 putRequest 延时线程 定时线程 threading.Timer(5, go) 5 秒之后执行go with 根据上下文环境自动打开释放 锁 with mutex with open() with conda 后台线程 前台线程 前台线程：主线程必须等待前台 threading.Thread 默认前台进程 后台线程：主线程不需要等待其他线程 setDaemon(True) 将前台线程转为后台线程 全局变量可以用于在线程之间传递数据 全局变量多个线程都可以读取 每个线程都有独立的空间 threading.local() 分配一个独立的存储空间 :]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python递归，深度遍历，广度遍历]]></title>
    <url>%2F2019%2F10%2F10%2FPython%E9%80%92%E5%BD%92%EF%BC%8C%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[递归 在程序中，通过栈结构实现 递归：函数自己调用自己 函数是使用栈结构表示的，先进后出，后进先出，和递归结构类似 深度遍历 函数顺序执行 最简单的递归结构 带有结束标志的递归结构 递归加法 树状递归 文件夹遍历函数 栈结构 线性表 栈结构易出现栈溢出 使用list模拟栈结构，可以有效的避免溢出问题深度遍历 使用列表模拟栈结构 目录结构比较混乱 只有最后一个分支比较正确 容易出现死循环，不适合提取数据广度遍历 使用队列 先进先出，一层层访问 网站提取数据优先使用 广度遍历]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式]]></title>
    <url>%2F2019%2F10%2F01%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式 Regular expression operations Python通过re库提供对正则表达式的支持 一般步骤 将正则表达式的字符串形式编译为Pattern实例 使用Pattern实例处理文本并获取匹配的结果Match实例 在match的基础上进行其他操作 Both patterns and strings to be searched can be Unicode strings (str) as well as 8-bit strings (bytes). 字符串和模板的字符串必须是str或者bytes，不能混合使用 预编译 编译：将程序翻译成二进制 预编译：提前将字符串模板成二进制 加快速度，编译好的模板数据可以多次使用 re.compile() 对象是 re.compile(‘(.)——(.)’) 已经编译的模板字符串可以当做match的参数 在处理大数据的时候比较有用 复杂的表达式需要预编译 re.complile(“*”).match() 常用的方式之一 方法 匹配字符 \b：空格和其他非单词字符 作为边界 \bthe the前面有空格或其他非单词字符 the\b the后面有空格或者其他非单词字符 \B 和上面的\b情况相反 re.match(pattern, string, flags=0) 匹配从第一开始 从首字母完整匹配 且只匹配一次，后面的不再处理 相当于 检查前缀字符串 If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. 字符串从头匹配，必须是字符串的起始位置 有匹配的，返回匹配的对象 re.Match 对象 包含位置和匹配对象 span match 使用.group()返回实际字符 或者直接在后面[0]，返回第一个匹配的数据 没有匹配的，返回None &lt;re.Match object; span=(0, 18), match=’chenyuqi is a gile’&gt; group()默认匹配字符串全部显示,省略了0 group()参数0,1等表示模板字符串中()的顺序对应的字符串 re.search(pattern, string, flags=0) 搜索 Scan through string* looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; 在字符串中搜索匹配模板的第一个位置，返回match对象 搜索包含就可以 &lt;re.Match object; span=(3, 6), match=’xyz’&gt;11 re.findall(pattern, string, flags=0) 查找所有的元素 从左到右，返回所有匹配结果字符串的列表 当匹配模式中包含多个组的时候，返回的是元素是元素的列表 字符串中模式的所有非重叠匹配 re.split(pattern, string, maxsplit=0, flags=0) 切割 Split string by the occurrences of pattern. 按照字符串模式切割字符串 和字符串的split函数类似，但是更为随意 re.finditer(pattern, string, flags=0) 筛选 同find，但是返回一个迭代器 re.sub(pattern, repl, string, count=0, flags=0) 替换，拦截关键字 使用repl替换根据pattern匹配到的字符串，返回新的字符串 默认替换所有的 re.subn(pattern, repl, string, count=0, flags=0) 原理同sub 但是返回的是一个元素(new_string, number_of_subs_made) （新的字符串，替换次数） 贪婪模式和非贪婪模式 是正则表达式匹配的两种模式 贪婪模式：匹配尽可能多的字符 非贪婪匹配模式：匹配尽可能少的字符 使用? 默认贪婪模式 常用的简单正则表达式 QQ号码 ^1-9$ Phone ^134578$ 电话 ^01-9-1-9 IP地址 ^(\d){1,3}.(\d){1,3}.(\d){1,3}.(\d){1,3}$ 简单的，不准去 0-255 0-9 19-99 100-199 200-255 200-249 250-255 ^(\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5]), (\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5]),(\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5]),(\d | [1-9]\d | 1(\d){2} | 2[0-4]\d | 25[0-5])$ 邮箱 \w+ \w(.|_|\w)+ \w(.|_|\w)+@ \w(.|_|\w)+@(\w+.){1,3}\w+ 出生日期 1985-05-22 01-12 01-31 (18\d{2}| 19\d{2} | 20[0-1]\d) 年份 (1[0-2] | 0[1-9]) 月份 0[1-9] |[1-2][0-9]| 3[0-1] 日期 ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面对对象编程2]]></title>
    <url>%2F2019%2F10%2F01%2FPython%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[类的继承123class 类名(父类): def __init__(self): super().__init__(self) 构造函数式 当父类和子类都有构造函数时 子类的构造函数必须引号分类的构造函数 传入参数 子类的构造函数参数列表必须包含父类构造函数的参数列表 super().init(参数列表) 父类的参数必须提供 注意，参数列表中没有self 调用父类的构造函数 父类名称.init(self, 参数列表) 必须有self 通过self指定是谁的上游，父类 super().init(参数列表) 不能有self super() super表示该类的父类 super()表示父类对象 继承 子类继承父类的属性和方法 子类拥有同名方法时，使用自己的方法 意义 代码，数据 重用 子类会覆盖父类,当出现同名属性和方法时 多继承 引用父类的初始化构造函数，容易出现覆盖属性的现象 程序顺序执行 只能使用第一种方法 类名.init(self) 类的__mro__属性表示类的查找方向 多继承：有多个父类 不同命的方法和属性： 重名的方法和属性：按照mro的指示查找，只要找到，就不在继续找了 属性的继承 没有init时，属性按照引用类的顺序使用 当有init时，属性会出现覆盖的情况，和父类的init初始化函数顺序有关 和属性的命名空间有关 属性是私有的 方法 只和类的顺序有关，谁在前，执行谁的方法 方法是共有的 私有属性不能继承 名称都变了，在外部使用不了 基类 object 所有的类都是从object继承的 但是 object 省略 类的特有属性 从object继承的 1234&#123;'__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__'&#125; name 类的名称 doc 说明文档 module 类的位置 bases 类的父类 dict 类的所有属性和值，字典 super 解决父类的初始化 解决父类的多次重复初始化的问题 只初始化一次 使用类名.init调用时，会多次初始化 super(类,self) 表示类的所有父类，而不是一个 不需要重复调用 节约资源isinstance(object, classinfo) 判断object是不是改类型的参数和子类 classinfo 可以是一个元祖 type对类型是属于严格检查 &lt;class ‘main.C’&gt; isinstance 对类的检查包括父类 多态 解决可扩展性 一个接口，多种形态 通过把对象当做参数，调用自己的方法，而不是继承的方法 静态方法 @staticmethod 只和类有关的，不需要实例化就可以使用的 不能使用cls和self 和 类对象和实例对象无关的方法 对象和类对象都可以调用 &lt;class ‘function’&gt; 不和对象，类绑定 类方法 把类当做参数 cls 类.方法 在外部使用 @classmethod 内部：类方法 @classmethod cls做参数 外部：把对象当做方法 同名函数可以覆盖，类的最后使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面对对象编程1]]></title>
    <url>%2F2019%2F10%2F01%2FPython%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[面对对象的编程思想 函数是对代码块的抽象，代码重用 面向对象编程是对代码重用的更高的方式 面向过程：根据业务逻辑从上到下写代码 函数式： 将某些功能代码封装到函数中，无需重复编写整个功能代码的实现，仅调用即可 面向对象：将函数进行封装，更快速的开发程序，减少重复代码的编写过程 代码的重用 数据的重用n 数据的封装，独立性 类与对象 类：蓝图，模型 对象： 根据类实例处理的，实际对应的 类的定义 class 关键字 类型 &lt;calss “type”&gt; 数据类型 可以初始化多个对象 对对象的属性和方法进行了封装 数据的重用 属性 代码的重用 方法 一般语法 1234class 类名称(): 代码块 属性： 变量 使用属性 self.变量 方法 函数 第一个参数 self 类的方法 类的方法是 bound method，绑定在self上 &lt;bound method People.say of &lt;main.People object at 0x000001FA8D05A188&gt;&gt; 所有的实例对象共用一个方法 本质 函数重用： 方法地址一样，共享的，绑定方法区分谁调用函数，方法共享 数据： 属性地址不一样，属于每一个对象，属性对立 构造函数 init(self) 对象创建时，自动运行的函数 传递参数，初始化对象 对应的是创建对象，实例化的参数列表 一般对象的属性是放在构造函数中的 类中默认包含构造函数 析构函数 del(self) 对象删除时或者生命周期结束时，自动运行的函数 动态绑定增加属性和方法 迭代开发 在对象实例化之后，使用对象.属性=数值进行增加属性 属性独属于该对象，其他对象不能共享 同列 方法类似 只能使用lambda 不能使用self 重载运算符 不同的类型对运算符有不同的解释 针对本类型，对运算符进行新的解释 不能出现对一个运算符的多种解释 有名对象和匿名对象 c = People() 有名对象 People() 匿名对象 类的复制 类似对象复制 属于地址引用 对象 类() 类的实例化 类型 &lt;class ‘main.star’&gt; 数据类型实例化 self self指向类实例化的对象，实例化以后的对象地址 self只能用在绑定的方法上，就是参数包含self的方法 在类定义中，self可以调用属性和方法 属性和方法属于实例化的对象 在类定义中使用属性必须是self.属性 方法的第一个参数必须是self 在类定义中，使用定义的方法也必须是self.方法 只应用于类定义的内部 函数 函数的参数本质是 浅拷贝，地址拷贝 不能改变原来数据的地址 字符串，数字；作为参数，原来的数据不会改变 字符串和数字存储的是常量 列表，字典 和 自定义类实例化的对象 列表，字典，和 自定义对象 是 一段内存地址 不能改变地址，但是可以改变内部元素存储的地址属性 私有变量 __变量: 变量前面加双下划线 只能在类定义的内部修改，对象不能随意修改，只能通过set和get函数获取和修改 私有变量在内部实际存储的是_classname__私有变量 意义 保护数据，设计权限 私有方法 同私有变量一样，禁止被人随意使用 私有方法 __方法名，在方法名前加__双下划线，拒绝外部访问 同理，私有方法可以使用_classname__方法访问 私有的本质 私有变量的本质就是讲方法和属性的名称重新命名了 __ ----&gt; _ClassName__ tkinter 窗体模块,界面 消息机制 操作系统的系统进程 通过消息原理控制操作系统 所有的windows应用都是消息驱动的 所有的操作都被当做消息处理 进程被放到一张表中，等待消息 windows系统提供一个死循环，检测鼠标，键盘，每检测到一个操作，添加对应的消息 消息循环 得到消息之后，会将信息传递给所有的进程队列 哪个进程可以执行，就执行 callback 消息触发进程 消息回调机制 异常处理机制 关键字 try except else finally 异常和错误 错误Error：大多指语法错误:解释器检查出来的 常见错误 常见错误： name Error 变量没定义 Systax Error 语法错误 IO Error 文件错误 Zero DivisionError 10/0,除零错误 Value Error 值错误，例如a = int（‘aa’） keyboard Interrupt 强制终止程序产生，ctrl+c强制终止程序运行 异常Exception、：不完整或者不合法输入或者计算出现问题 异常产生，检查到错误且解释器认为是异常，抛出异常 异常处理，截获异常，忽略或终止程序处理异常 处理异常 语法12345678910try: 语句块except 异常类型1： 处理语句except 异常类型2: 处理语句else: 没有出现异常，执行的语句finally: 一定执行的语句 raise 显示的引发异常 可以是非语法的异常，自己设定的异常 一旦执行raise语句，后面的语句不会再执行，程序结束 raise 的参数不能被except处理 raise [Exception [, args [, traceback]]] 关键字 with as 根据上下文管理，可以自动的关闭打开的文件 assert 断言 判断一个表达式 在表达式为False时触发异常 assert expression [, arguments] 等价 if not expression: raise AssertionError(arguments) AssertionError: 被除数不能为0 对 raise的 进一步细化 表达式为Flase的情况下触AssertError]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件读写]]></title>
    <url>%2F2019%2F10%2F01%2FPython%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[字符串的输出 str 返回一个用户易读的表达形式 repr 返回一个解释器易读的表达形式 字符串 带引号和转义 返回包含对象的可打印形式的字符串 可以处理任何类型，表示类型 返回对象的字符串形式 字符串当作一个对象，再次当作普通对象处理 其他类型的也是一致的 eval(repr(A)) == A 调用repr 函数 compute the “official” string representation of an object Return the canonical string representation of the object. 对比 对于一般数据而言，相同 在命令行中对比比较好 str统一转换为字符串，看不到类型 标准输入和输出 标准的输入和输出是 控制台 可以使用重定向符号 将输入和输出定向到其他地方 shu.py &lt; 1.txt &gt; 2.txt 从1.txt 读入内容 向2.txt 输出内容 文件读写文件对象 file object File objects are also called file-like objects or streams. &lt;_io.BufferedReader name=’E:\项目\Python\zhaolong\study\09-19\txt\6.chuci.txt’ 类文件对象或流 三类文件对象 raw binary files, buffered binary files and text files. 二进制文件（原始二进制文件，缓冲二进制文件），文本文件 将面向文件的API暴露给底层资源对象 根据创建文件的方式，文件对象可以调教对真是存储文件或其它类型存储或通信设备的访问 创建文件对象的规范方法是open()函数 open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) Open file and return a corresponding file object. If the file cannot be opened, an OSError is raised. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed, unless closefd is set to False.) file 是一个类似路径的对象 要打开文件的路径名(绝对路径或者当前工作目录的相对路径) 整型的文件描述符 mode is an optional string that specifies the mode in which the file is opened mode 可选，默认’r’ 同义词 rt read text 指定文件的打开模式 错误处理机制 errors：如何处理编码和解码错误 常用的时 ignore：忽略错误，强制解码 Python区分文本和二进制I/O， 二进制打开模式’b’，返回bytes，没有任何编码 文本打开模式t,返回str，使用平台相关的编码或者指定的编码进行解码 windows系统文本中默认的gbk编码格式,open中没有标明编码格式的话，默认使用系统编码格式 UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x9f in position 22: illegal multibyte sequence 默认中文环境gbk，ansi，系统自动寻找编码解码和编码 使用多个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码; 在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码 不同 ANSI 编码之间互不兼容 python的默认编码也是 utf-8 中文写入 中文需要使用编码 常用’’utf-8’或者’gbk’ 使用utf-8编码，以二进制写入，不会受平台影响 不同的编码会导致编码失败，主要时某个编码的字符，其他编码没有 解决方案: 在编码重合度很高的情况下，忽略编码错误，也可以解码，但也可能出现完全乱码 由于系统编码的不确定性，指定编码，或者直接进行二进制写入 编码必须保持一致 缓存区 buffer 数据写入文件非实时的 用于设置 缓冲 策略 0- 关闭缓存 - 仅在二进制模式下 1- line buffer 行缓存，仅在文本模式下可用 &gt; 1 指定大小的块缓存区 byte buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable in text mode), and an integer &gt; 1 to indicate the size in bytes of a fixed-size chunk buffer. 默认情况 Binary files are buffered in fixed-size chunks; 4096 or 8192 bytes long. “Interactive” text files (files for which isatty() returns True) use line buffering. Other text files use the policy described above for binary files. flush 方法 实时写入 如果程序未正常结束，也可以保证数据已经写入 读取文件 内存模式 read readlines 硬盘模式：readline 4.1 read(size=-1) * Read and return at most size characters from the stream as a single str. * If size is negative or None, reads until EOF. * 按照size读取字符，作为一个新的字符串 * 如果size为空，则 全部去读 4.2 readline(size=-1) * Read until newline or EOF and return a single str. * If the stream is already at EOF, an empty string is returned. * If size is specified, **at most size characters will be read** * 读取一行或者到eof * size指定，读取指定数量的字符,但是遇到换行符也会停止 * 意思就是 相当于 由**两个换行符** * 指定的字符数 size * 换行符 4.3 readlines(hint=-1) * Read and return a list of lines from the stream. * hint can be specified to control the number of lines read: * no more lines will be read if the total size (in bytes/characters) of all lines so far exceeds hint. * 返回一个由行组成的列表，每行包含换行符 * 参数是行数，指定读取的行数(包含这次**已读取的行数**) 文件指针 文件对象是流对象 包含 文件指针 会指向当前读取的字符 文件指针只会向后运动，不会向前移动 当文件指针指向EOF，文件读取结束 函数 tell() Return the current stream position as an opaque number. The number does not usually represent a number of bytes in the underlying binary storage. 返回当前的文件指针指向的位置,并不是字符数 该数字通常不代表底层二进制存储中的多个字节。 汉字 3 符号 3 从0开始 seek(offset[, whence]) 设置当前块中文件指针的位置 whence 可选 0 默认 绝对位置 1 相对于当前的位置 io.UnsupportedOperation: can t do nonzero cur-relative seeks file 不做非0相对搜索 2 相对于文件EOF 常用作回到文件开头,末尾不是EOF，而是 数值 文件对象的遍历 文件对象拥有__next__和__iter__特殊方法，支持迭代协议，属于可迭代对象 for line in fileobj: 不等同于 fileobj.readlins（）,一次性读取到内存中 而是按照next函数，一行行的取出数据pickle 数据序列和反序列化，常用于持久化，保存到文件 pickle Python object serialization The pickle module implements binary protocols for serializing and de-serializing a Python object structure pickle模块为python对象结构实现序列化和反序列化的二进制协议 “Pickling” is the process whereby a Python object hierarchy is converted into a byte stream pickle 是 将python对象层次结构转化为字节流的过程 unpickle 是一个反向操作 即将字节流(来自二进制文件或类似字节的对象)转换回对象层次结构 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久保存 通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象 序列化函数 dump() pickle.dump(obj, file, protocol=None, *, fix_imports=True) Write a pickled representation of obj to the open file object file. This is equivalent to Pickler(file, protocol).dump(obj). 将对象的pickle表示写入打开文件对象中 protocol 是支持的协议 file 对象必须是fileobj，拥有write方法 pickle.dumps(obj, protocol=None, *, fix_imports=True) Return the pickled representation of the object as a bytes object, instead of writing it to a file. 返回对象的pickle表示，而不是写入文件反序列化函数 load() pickle.load(file, *, fix_imports=True, encoding=”ASCII”, errors=”strict”) Read a pickled object representation from the open file object file and return the reconstituted object hierarchy specified therein. This is equivalent to Unpickler(file).load(). 从打开的文件对象中读取经过pickle的对象，并且重构Python对象类型 file 必须提供read()和readline()方法 pickle.loads(bytes_object, *, fix_imports=True, encoding=”ASCII”, errors=”strict”) Read a pickled object hierarchy from a bytes object and return the reconstituted object hierarchy specified therein. 从字节对象中读取picked的对象，并且重构Python对象类型 os 模块 操作系统接口 This module provides a portable way of using operating system dependent functionality. os.popen() 和 os.system() 同样可以指向指令 os.system无法获取返回的结果 os.popen() 返回一个文件对象*，连接的命令, Python 把所有的设备当作文件处理，文件的重定向 返回的对象可以读取和写入，根据mode确定 返回的是字符串对象，而不是bytes 文件夹编程 os.listdir() 遍历文件夹下的所有文件 os.mkdir() 创建一个文件夹 必须一层层的创建，不能跨层创建 os.rmdir() 删除文件夹 只能删除空目录 os.remove() 删除文件 os.rename() 重命名 os.path.isfile() os.path.isdir() 判断是否是文件或目录 排列组合 itertools.permutations(iterable, r=None) 返回元素长度为r的排列 包含 元素相同，顺序不同 的情况 r 默认None 函数使用全部长度 r &lt;= len(iterable) itertools.combinations(iterable, r) 返回元素长度为r的组合 没有顺序 注意 返回的都是迭代器 必须使用list转化为list元素 itertools.product(*iterables, repeat=1) 生成可迭代对象的笛卡尔积，repeat指元素的个数]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表，字典，集合详解]]></title>
    <url>%2F2019%2F09%2F23%2FPython%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[列表详细 元组详细 集合详细 字典详细 迭代器object.hash(self) * Called by built-in function hash() and for operations on members of hashed collections including set, frozenset, and dict. hashable An object is hashable if it has a hash value which never changes during its lifetime (it needs a hash() method), and can be compared to other objects (it needs an eq() method). Hashable objects which compare equal must have the same hash value. Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally. hashable 可以用做dict的key和set的number，这些数字类型内部元素的可以hashbale &gt; Most of Python’s immutable built-in objects are hashable; &gt; mutable containers (such as lists or dictionaries) are not; &gt; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. 不可变内置数据类型 是 hashable :str frozenset 可变容器类型 是 unhashable: list dict unhashable type: &#39;set&#39; 不可变容器类型元素是hashable的话，他们才是hashable：tuple fronzenset Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id(). list 列表列表的构造 使用方括号[]表示空列表 使用方括号[],其中逗号,分割元素 使用列表解析，[x for x in iterable] 使用类型构造函数，list()或者list(iterable) 使用构造函数构造列表，列表的元素和iterable的元素相同且顺序相同 没有参数，返回一个空列表内存结构 list是内存中的一段地址的集合，赋值是从一个地址的集合转到另一个地址的集合 字符串存放的是一个地址，list是一堆地址 list内部的存储的是元素的地址，通过索引进行操作，引用 list内部的元素是可以变化的，可以添加元素，删除元素等操作，可以单独修改引用地址 list内部的元素类型是不固定的，list只记录元素的地址，通过索引调用 修改单独元素不会影响list的值，只有整体赋值才能影响list，也就是将list指向新的地址段 list特点 多个变量组成的集合，每个变量可以存储不同的地址 可以包含不同类型的变量地址 对list中的元素进行增删改，不会影响list 每个元素都有自己的独立地址 索引 从0开始，通过索引操作元素，修改元素 索引：[0-len(list)-1] 或者 [0,-1] 正向索引和负向索引 负向索引 -m = len(list)-m 索引的切片操作[m,n] 包含m，不包含n ⚠ 循环 遍历元素 for x in list: x是元素的值，而不是元素，data = mylist[1]，元素的copy，副本 只能打印列表元素的值 不能对元素进行修改等操作 下标循环 for i in range(len(list)) i – 是索引 list[i] 可以操作元素，包括打印输出，修改操作 del del 是关键字 属于声明 del是递归定义的，与定义赋值的方式非常相似 删除列表会自左向右递归删除每个目标 Deletion of a name removes the binding of that name from the local or global namespace, depending on whether the name occurs in a global statement in the same code block. 删除名称将删除名称与本地或全变量的绑定 相当于内存回收 删除list的元素的时候，会出现索引越界的问题 del list[1] 添加break语句，不会出现越界的问题 删除一个元素之后，索引及时变化，会向左移动 list是一个比较紧凑的数据结构 列表的运算符 in / not in 成员运算符，判断是否存在与列表中 只会判断第一层的元素 True False + 列表的元素拼接 归并 * 列表的元素重复 列表的嵌套 列表的元素是列表 嵌套列表的访问需要使用嵌套for语句 表示矩阵 常见的嵌套列表是单个元素和列表元素同时存在，打印时小心处理,str有索引，但是输出不合理，int没有索引 isinstance(object, classinfo) 判断object是否是classinfo的实例 Return true if the object argument is an instance of the classinfo argument, or of a (direct, indirect or virtual) subclass thereof. 列表的常见方法 Lists implement all of the common and mutable sequence operations. 列表实现所有的常见和可变序列操作 支持基本的序列操作 1.append() * 添加元素到最后一个位置 * 把参数当作一个元素 index() 查找第一个出现的索引 只会查找list的元素，不会进入元素内部查找 count() 统计元素出现的次数 reverse() 将列表元素反转 顺序反转，不排序 sort(*, key=None, reverse=False) 按照元素的大小进行排序 reverse=True 从大到小 不合适嵌套的列表 clear() 序列的操作 清空列表 pop() 弹出最后一个元素 返回最后一个元素，并且列表也会发生变化 remove() 删除列表中的默认元素 没有返回值 insert() 相当于 s[i:i] = [x]) 在索引位置插入元素，之前的后移 list的拷贝 python是地址赋值，地址引用 在list中 =简单的地址引用 两个变量指向同一个list is -&gt; True 节约内存 数据共享，一个修改，另一个变量的值也发生变化了 shadow copy 浅拷贝 s.copy() creates a shallow copy of s (same as s[:]) 浅拷贝 类似第一层的切片 第二层列表共享 和 copy库中的copy.copy 功能一致 deep copy 深拷贝 递归拷贝对象 所有的数据都保存为副本 数据之间独立，不共享 浅复制和深复制之间的区别仅与复合对象（包含其他对象的对象，如列表或类实例）相关 A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original. A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original. 浅拷贝是将它的引用插入到原始对象中 深拷贝是递归方式将复制对象插入到原始对象中找到的对象 深拷贝会复制它可能复制的所有内容 递归对象（直接或间接包含对自身的引用的复合对象）可能会导致递归循环。 tuple 元组 元组属于不可变序列，用于存储异构数据的集合 构造 () 表示空元组 单例元组使用 a trailing comma for a singleton tuple 末尾逗号 （a,） 使用逗号分割元素 函数内置函数tuple() Note that it is actually the comma which makes a tuple, not the parentheses. 本质上是由逗号确定元组的 可以不加括号，但是不常用 本质 元素属于序列，基本满足序列的操作 通过索引进行元素的操作，只能打印 元素 不可变 和list对比，存储的是地址常量，而且list中存储的是地址变量 索引 正向索引 负向索引 切片操作 左开右闭合 [) 元素符号 拼接 复制 in 成员操作符 in 判断第一层的元素 循环 元素遍历循环 下标循环 max,min 返回最大，最小的元素 如果有嵌套的，报错 集合 A set object is an unordered collection of distinct hashable objects 不同哈希对象的无序集合 不重复元素的无序集合 不支持索引 用途 成员资格测试 从序列中删除重复项 数学运算（差集，交集，补集） 无序集合，不记录元素的元素的位置和插入顺序，不支持索引，切片或其他类似序列的操作 有两种类型set和frozenset class set([iterable]) The set type is mutable — the contents can be changed using methods like add() and remove(). Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. class frozenset([iterable]) The frozenset type is immutable and hashable — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.构造set 使用大括号{}定义 元素之间用逗号隔开 set([iterable]) 可迭代对象拆分成了 集合 {} 定义的是dict 空set使用set()定义 输出也是 set() set(set)：使用set重新创建set，两个不一致 set集合没有顺序 从字典转换成集合 注意：只有key值 集合不能进行单独元素的操作 set的函数 add(elem) Add element elem to the set. 注意 set的元素是hashable的，所以不能添加list和set， update(*others) Update a set with the union of itself and others 参数是iterable TypeError: ‘int’ object is not iterable 会将可迭代对象的每个元素和原set进行union操作 remove 删除元素,但是元素不存在时，会报错 KeyError: 1 Remove an element from a set; it must be a member. If the element is not a member, raise a KeyError. discard(elem) Remove element elem from the set if it is present. 删除元素，如果存在与set中，则删除 不存在与set中，do nothing pop Remove and return an arbitrary element from the set. Raises KeyError if the set is empty 从集合中删除和返回任意元素 集合为空，会引发keyError错误 clear Remove all elements from the set. difference(*others) set - other - … Return a new set with elements in the set that are not in the others. 返回一个集合，元素在set中，而不在other中 表示差集 A.difference(B) == A-B isdisjoint(other) Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set. 没有交集 set的循环 没有索引操作，只能使用in操作符元素遍历 类型转换 tuple set list set无法单独操作每个元素 循环遍历中的是 副本 可以修改副本，但是修改不了原本 如果要操作单个元素，可以转化成list，修改之后，再次转换回来 集合的运算符 - 差集 A - B：A中存在的元素，B中不存在 &amp; 交集 A &amp; B：元素存在于A中，也存在B中 和集合的前后顺序无关 | 并集 返回一个集合 A | B: 元素存在与A或者B中 ^ 并集 - 交集 A ^ B: 分别存在A或者B集合中 == 判断A和B元素是否相等 只要元素分别存在与两个集合中返回True 不考虑顺序，set没有顺序 in 用于判断元素是否是否属于集合 如果是 set in set 返回False11集合的关系运算符 issubset(other) 包含 set &lt;= other Test whether every element in the set is in other. 测试set中的元素是否存在与other set &lt; other Test whether the set is a proper subset of other, that is, set &lt;= other and set != other. 测试set的是不是other的子集， issuperset(other) 被包含 set &gt;= other Test whether every element in other is in the set. set &gt; other Test whether the set is a proper superset of other, that is, set &gt;= other and set != other. mapping type —&gt; dict 映射 A mapping object maps hashable values to arbitrary objects. 映射对象：可哈希值映射到任意的对象 mapping 是可变类型，目前标准映射只有dict 字典 Key：几乎任意值，但是必须是可哈希的 Value：任意值 list，dict和set 不能作为key Dictionaries can be created by placing a comma-separated list of key: value pairs within braces 可变数据类型，存储任意类型对象 集合的加强版，可以使用key调用value；key和set的元素类似 key的value可以被覆盖，按照录入顺序构造 class dict(**kwarg) 关键字参数 name=”zhaolong” 其中前一个不需要引号 class dict(mapping, **kwarg) 映射类型 如 zip函数 class dict(iterable, **kwarg) 可迭代一对 [(,)] dict() 或者 {} 创建空字典 通过key值引用value dict[key] 映射函数 zip(*iterables) 参数是多个可迭代数据，或者可迭代的列表 Make an iterator that aggregates elements from each of the iterables. 根据多个迭代对象的对应元素创建一个迭代对象 返回一个元组的迭代器，元素来自与参数迭代对象的对应元素 The iterator stops when the shortest input iterable is exhausted. 当其中任意一个可迭代对象停止时，结束 123456789101112def zip(*iterables):# zip('ABCD', 'xy') --&gt; Ax Bysentinel = object()iterators = [iter(it) for it in iterables]while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) zip() 函数可用于解压缩列表 字典的更新 in 判断键值是否存在，不判断值 key in d Return True if d has a key key, else False. key not in d Equivalent to not key in d. 2.del d[key] * Remove d[key] from d. Raises a KeyError if key is not in the map. clear() Remove all items from the dictionary. len(d) Return the number of items in the dictionary d. copy() Return a shallow copy of the dictionary. get(key[, default]) Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError. items() Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects. keys() Return a new view of the dictionary’s keys. See the documentation of view objects. values() Return a new view of the dictionary’s values. See the documentation of view objects. a set-like object providing a view on D’s items 都是可以迭代的 update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None. 会使用参数dict的键值对更新dict，如果存在，覆盖；如果不存在，返回None 会更新dict setdefault(key[, default]) If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None. 迭代器 迭代器协议 iter next StopIteration 常用在for in环境中 可迭代对象 和 迭代器 的协议稍微不一致 生成器 generator列表生成式：[x for x in range(100)] 一次性全部删除，浪费内存 非常暴力的占用内存，严重浪费生成器 一次生成一个数据，节约内存 使用关键字 yield生成生成器函数 或者生成器表达式()列表生成器 (x for x in range(100)) 使用 next() 生成器函数 和常规函数没有区别 但是 在内部使用了关键字 yield 其中 函数名：函数 函数调用：函数名() 的类型时generator 第一次执行：到达yield 返回内存 第二次调用：继续上一次执行的地方继续执行 注意 使用的时候，首先 将函数生成器赋值给变量，以防每次使用生成一个新的生成器 x=go() yield 在函数常和for搭配使用 生成器函数只能通过next()调用 因为 函数名() 已经变成一个 generator 了 必须使用 next() 常用于读取文件]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串详解]]></title>
    <url>%2F2019%2F09%2F23%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[字符串详解eval 和 evec eval： eval 语句用来计算存储在字符串中的有效表达式 内置函数 可以转化为实数,只能处理字符串形式的表达式 常见的使用：num = eval(input(&quot;输入数据:&quot;)) The expression argument is parsed and evaluated as a Python expression eval(&quot;2+2&quot;) 参数是 “字符串” eval() arg 1 must be a string, bytes or code object 将文本当作表达式使用 exec： exec 语句 用来执行存储在字符串或文件中的python语句 exec(print(&quot;hello world&quot;)) This function supports dynamic execution of Python code. object must be either a string or a code object The source may be a string representing one or more Python statements 处理字符串形式的python语句 将文本当作语句执行 exec() arg 1 must be a string, bytes or code object repr Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a repr() method. 返回一个包含可打印表示的字符串 可以直接交给eval使用，但是输出的结果依然是repr()的参数 主要用来取得对象的规范字符串表示，反引号也可以完成相同的功能 大多数时候eval(repr(object)) == object repr 加了一层引号 eval 去掉一层引号 使用repr方法控制repr的返回内容 字符串的操作字符串的三种风格 单引号 一般用于字符 双引号 一般用于字符串 三引号 主要解决多行字符串的问题字符串的基础单位 字符 - 最小的字符单位 unicode字符 字母，符号(单的)，汉字 字符 字符在Python的定义的是bytes，也就是字节流，包含多个字符 python中定义字符使用b&#39;&#39; 或者使用 str.encode() bytes can only contain ASCII literal characters 简单的字母 字符串的截取 字符串属于序列，可以使用切片操作，索引从0开始 正向索引和负向索引可以混合使用 字符串赋值 字符串不支持元素赋值 ‘str’ object does not support item assignment 字符串是不可变数据类型 可以对字符串赋值为新的常量字符串 字符串除非重新赋值，否则字符串不会改变 转义字符 采用某些方式暂时取消该字符本来的含义python中使用\+字符方式表示 作用 表示不可打印字符 \b \t \a 退格 tab 蜂鸣 解决字符串中的\t等引起的错误–&gt; ‘\t’ 最常用于目录 \\ 表示\,而不是转义符号 主要用于windows系统中，windows系统中\用于目录分隔符 字符串常见运算符 + 字符串的拼接 两边只能是str，不能出现int TypeError: can only concatenate str (not “int”) to str 字符串的乘法 序列的乘法 只能和整数相乘 TypeError: can’t multiply sequence by non-int of type ‘str’ TypeError: can’t multiply sequence by non-int of type ‘float’ [] 字符串的截取 序列的截取 str[n] str[m,n,step] in / not in 成员操作符 ch in str: ch是否存在于str中，返回True和False ch 可以是单个字符，也可以是字符串 换行 \n和\r\n 都起到换行符 和平台有关，一般可以兼容，效果是一样 \n 回车，光标在下一行 \r 换行，光标在上一行 字符串的格式化 format() Convert a value to a “formatted” representation, as controlled by format_spec. The interpretation of format_spec will depend on the type of the valueargument “Format specifications” are used within replacement fields containedwithin a format string to define how individual values are presented 12345678format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type]fill ::= &lt;any character&gt; # 填充字符align ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot; # 对其角度sign ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot; # 标志，仅对数字有效width ::= digit+ # 宽度grouping_option ::= &quot;_&quot; | &quot;,&quot; # 数字千分位precision ::= digit+ # 精度type ::= &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot; #类型a 用法 函数 format(&quot;字符串&quot;,&quot;格式化表达式&quot;) 方法 &quot;{}，{}，{}&quot;.format(字符串，字符串) 函数 参数：和格式字符串中的类型一致 函数 会将 数据 按照类型进行处理，转换成字符串 ValueError: Unknown format code ‘f’ for object of type ‘str’ 格式化字符串 “%s”.% num 一个完整的字符串 %替换内容 %[填充符号][对齐][宽度][,千分位][.精度][类型] 填充：默认空格 对齐: &lt; &gt; = 特殊表现 %%:特殊的转义字符，表示输出一个% %转移字符 字符串编码 Python2中，普通的字符是以8位的ASCII码进行存储的，而Unicode字符串则存储为16为Unicode字符串,使用的语法是在字符串前加u python3中, 所有的字符串都是Unicode字符串 ASCII格式没有中文，可以编译 但是存储中文的话，不能通过编译，必须使用utf-8 utf-8和ASCII比较 同等条件下，空间占用较大 utf-8 可以编译中文 python3中默认字符集Unicode，默认编码格式utf-8 原始字符串 Both string and bytes literals may optionally be prefixed with a letter ‘r’ or ‘R’; such strings are called raw strings and treat backslashes as literal characters. As a result, in string literals, ‘\U’ and ‘\u’ escapes in raw strings are not treated specially. 格式： r&quot;字符串&quot; 但是如果字符串本身带着&quot;,r 不适用 查看字符串帮助 dir(‘’) Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object. If the object does not provide dir(), the function tries its best to gather information from the object’s dict attribute, if defined, and from its type object. The resulting list is not necessarily complete, and may be inaccurate when the object has a custom getattr(). 输出包含对象所属类型的属性和方法的列表 获取对象有哪些属性和方法 help() 查看对象的具体属性的文档 第一种风格：”“.find 使用&lt;对象&gt;.&lt;方法/属性&gt; 查看 第二种风格：str.find 使用&lt;类型&gt;.&lt;方法/属性&gt; 查看 字符串的方法和函数 字符串的方法和函数数量比较多 字符串是不可变数据类型，他的方法都返回一个新的字符串，不会对原始的字符串产生影响 常用方法和函数 str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. 返回一个首字母大写，其余字母小写的副本 只对英文字符起作用 str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). 返回一个长度是width的字符串，其中原本字符串居中，两边用fillchar填充 fillchar 默认 空格 str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. 返回索引范围内的非重叠出现次数 切片默认是整个字符串1 str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. 判断字符串是否是stuffix 后缀 结尾 后缀可以是个元组 本质上是判断以什么字符结尾 可以用作判断后缀 相反的str.startswith(prefix[, start[, end]]) str.expandtabs(tabsize=8) 返回一个副本，字符串中的tab键由指定的空格数替换 默认的是8 Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. 查找函数，找不到返回 -1 注意 只是在需要知道sub在那个位置时，才使用find 如果需要判断是否在字符串中，需要使用in rfind() Return the highest index in the string where substring sub is found, sub重复出现，返回最高的索引 index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found. 和find相似 但是当sub不存在的时候，报ValueError rindex() 和 rfind() 类似 判断函数 判断字符串是不是数字的，纯字符的等 方法 解释 isalnum 一个字母数字字符串，不能出现汉字和其他符号 isalpha 一个字母字符串，所有字符全部是字母，不能包含数字 isascii 有acsii码组成的字符串，其中””空字符串也属于 isdecimal 十进制字符串 isdigit 数字字符串,和上面稍微不一样 isnumeric 所有字符都是数字 islower 判断小写 isspace 空格字符串，不是空字符串；包含·’\t’,’\n’,’\r’等空白字符 istitle 标题字符串，第一个大写，其他字符小写,注意含有空格的情况下，每个空格后第一个字母都要大写 注意：判断字符串中字符的情况是在非空字符串的条件下 注意：汉字没有大小写之分 当字符串中全部是汉字时，isupper和islower结果是False 当字符串中包含其他字符和汉字时，isupper和islower会忽略汉字进行判断 可打印字符和空字符 isspace() 字符串中只有空格字符且至少有一个字符 空白字符：是Unicode数据库中定义的’others’和’Separator’字符 isprintale() 字符串中所有字符是可打印的或则空字符串 Nonprintable characters are those characters defined in the Unicode character database as “Other” or “Separator”, excepting the ASCII space (0x20) which is considered printable. 0x20 是空格，是可以打印的 在上下文环境中，repr()转移的字符是不可打印字符 str.join(iterable) Return a string which is the concatenation of the strings in iterable The separator between elements is the string providing this method. 参数是可迭代的对象 分隔符参数提供了该方法 按照指定的字符作为间隔符和可迭代对象生成新的字符串 str.rjust(width[, fillchar]) 类似center，但是是左边填充 ljust： 右边填充 str.lower() / upper() 对 中文字符无意义 字符全部转换成大写，或者小写 常用 忽略大小写 str.replace(old, new[, count]) 如果没有count参数，则替换所有的old字符 如果有count参数，根据count的数量从前到后进行替换 str.strip([chars]) 返回一个已经删除了最前面或者最后面chars字符的字符串 chars =None或者省略时，删除空格 chars：要删除的字符集，不是前缀或后缀，是所有值的组合都被剥离 The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped 有两个形同的 rstrip()和lstrip() 表示从右边或左边删除 删除字符集中字符直到不属于集合中的字符截至，不能间断 str.zfill(width) Return a copy of the string left filled with ASCII ‘0’ digits to make a string of length width. A leading sign prefix (‘+’/‘-‘) is handled by inserting the padding after the sign character rather than before 在左边填充0达到指定的长度 带有符号的对象，在符号和数值中间填充 str.swapcase() Return a copy of the string with uppercase characters converted to lowercase and vice versa. 修改字符串中字符的大小写，大写转小写，小写转大写，字符级别的 str.translate(table) Return a copy of the string in which each character has been mapped through the given translation table. 每个元素对照翻译表 The table must be an object that implements indexing via getitem(), typically a mapping or sequence. 翻译表必须可以通过gititem()，一般是映射和序列 You can use str.maketrans() to create a translation map from character-to-character mappings in different formats. 使用str,maketrans()创建字符-字符的映射 static str.maketrans(x[, y[, z]]) 是一个静态方法 用于创建str.translate()的转换表 一个参数的话，必须是字典，将Unicode序列，字符映射到另一个Unicode序列 两个参数，必须是两个长度相等的字符串 第三个参数表示指向None，翻译的时候也是None，表示的是省略字符串的切割 str.split(sep=None, maxsplit=-1) 将字符串按照sep进行分割，返回包含字符的列表 sep 默认是 空格， 但是字符串前面或后面的空格不参与 leading or trailing whitespace,在sep为None的情况下 字符串中间的连续空格被当作一个处理 如果sep是其他字符，字符串中的空格也会被处理成一个元素&quot;&quot; 而且不会在换行的地方产生新的元素，a\nv maxsplit 限制切割次数 默认 -1：即尽可能的分割 列表最大有 maxsplit+1个元素 str.splitlines([keepends]) 按行切割 返回包含行的列表 keepends 保留边界字符，也就是换行符，默认不保留 字符串中三种数字的对比 在unicode定义中，一下所有的都是数字 示例 1234⅐ ⅑ ⅒ ⅓ ⅔ ⅕ ⅖ ⅗ ⅘ ⅙ ⅚ ⅛ ⅜ ⅝ ⅞ ⅟Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ Ⅷ Ⅸ Ⅹ Ⅺ Ⅻ Ⅼ Ⅽ Ⅾ Ⅿⅰ ⅱ ⅲ ⅳ ⅴ ⅵ ⅶ ⅷ ⅸ ⅹ ⅺ ⅻ ⅼ ⅽ ⅾ ⅿↀ ↁ ↂ Ↄ ↄ ↅ ↆ ↇ ↈ ↉ ↊ ↋ isdecimal 十进制数字，也就是阿拉伯数字，包含全角和半角 Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character in the Unicode General Category “Nd”. isdigit Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal. 包含十进制字符和一些特殊处理的数字，不一定基于十进制数字 经过特殊处理的如 ①，¹ 等 isnumberic Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric. 包含digit，和所有具有Unicode数值属性的字符 具有Unicode数值属性的所有字符字符串的编码 Return an encoded version of the string as a bytes object. Default encoding is ‘utf-8’. errors may be given to set a different error handling scheme. The default for errors is ‘strict’, meaning that encoding errors raise a UnicodeError 对字符串按照提供的编码格式进行编码，转成bytes error handling bytes Bytes objects are immutable sequences of single bytes. 字节对象是单个字符的不可变序列 单个字符-【0，255】 字节 一个byte = 8个bit = 28 = **256 ASCII 第一位表示正负标识，其余7为表示字符 定义： bytes() 转换成二进制表示 包含汉字的必须使用bytes转换成二进制 英文，数字 都转换成了 二进制 使用十六进制表示 b1:表示字符串的二进制 字符串可以使用简单的ASCII表示 在Python中 字符串编码encode后 中文 –》 十六进制 英文和数字(&lt;255): —&gt; b’英文/数字’ 解码 b’0x*****’ —&gt; 中文 b’1’ —-》 ‘1’ class bytes([source[, encoding[, errors]]]) Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a b prefix is added: 字节和字符串的语法基本相同，不过前面添加了b Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence. 字节只使用127个ASCII字符 In addition to the literal forms, bytes objects can be created in a number of other ways:A zero-filled bytes object of a specified length: bytes(10)From an iterable of integers: bytes(range(20))Copying existing binary data via the buffer protocol: bytes(obj) bytes的使用utf-8 与 汉字 utf-8 使用三个字符表示汉字，其中1个表示结束，1个表示开始 gbk 使用两个字符表示汉字，没有结束符 不同的编码，对汉字表示不一致，所有解码和编码的编码格式必须一致，否则解码错误文件存储在硬盘和文件中存储的是二进制方式编码解码 str 字符串 编码成 二进制 encode() bytes 字节 解码 —》 字符串 decode() 注意：编码格式一致,否则代码错误或者乱码 主要是对 中文 英文的编码在任何字符集中都是一致的 字符集是在ASCII码的基础上发展的 应用： 爬虫抓取网页 容错性 Bytes() 的错误处理 机制 error handling ignore 解码失败的情况下，强行解码 strics 默认的，报错 UnicodeDecodeError 字符串的模板 字符串模板，做好模板，使用$变量等待传入数据 提供了更为简单的字符串替换 Template String 使用了基于$变量的替换 使用单个的$ ${identifier}或则和$identifier:同样的作用，主要是区分占位符 class string.Template(template) 单个参数，即构造字符串 substitute(mapping, **kwds) 执行模板替换，返回一个新的字符串 mapping：类似字典的对象，键值和模板占位符匹配 也可以提供关键字参数 safe_substitute(mapping, **kwds) 同上一个，稍微优化]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础数据类型]]></title>
    <url>%2F2019%2F09%2F23%2FPython%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基础数据类型字符串 零个或多个字符的有序集合 属于 序列 可以进行序列操作，如[] 索引从0开始 for循环遍历 enumrate() 函数 enumerate(iterable, start=0) Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The next() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable. 返回一个枚举对象，有元组组成 元组的元素是 可迭代对象的值和索引12345def enumerate(sequence, start=0): n = start for elem in sequence: yield n, elem n += 1 字符串的操作 字符串的截取 str[start:stop:step] 不包含stop step 默认1 [0:0:-1] 反序 字符串索引 正向索引：从0开始，从左到右 反向索引：从-1开始，从右到左 字符串操作符 字符串拼接 字符串重复 后面接数字 in 成员元素符 字符串的循环 in操作符，使用字符遍历 索引，使用索引遍历 主要用途：加密和解密 字符串本质 字符串是零个或多个字符和有序集合 字符串内部是不可更改的 没有对字符串中单个字符赋值的操作 TypeError: ‘str’ object does not support item assignment 字符串是一个整体 字符串属于不可变数据类型 可以赋值，但是是指向 新的字符串 list 列表 一组元素的集合，使用[]包括，且元素之间使用,隔开 属于 序列 list操作 for循环遍历 元素循环 for ch in list 索引索引 range(len(list) - 1) len() 统计list的元组个数 append() 列表添加元素，在末端位置 添加的是一个元素 参数是列表的话，当作一个元素 和 + 区别 1 extend() 列表末尾添加元素 参数是可迭代对象，添加元素 extend 和 append index() 返回元素的索引位置， 如果没有的话，报错 ValueError: -3 is not in list 切片 [::-1] 反序 需要赋值给其他变量 和 字符串一致 列表的拼接 列表各个元素的拼接 * 复制两次 使用的是列表的元素 列表的本质 列表属于可变数据类型 列表的元素可以变化 元素改变之后列表的地址没有变化list 容量 可以用到内存的尽头 tuple 元组 不被修改的list，用()定义 属于序列 循环方式一致 循环的作用只能输出打印 不可变数据类型 元组的元素不能修改，属于常量 元组的特例 创建单元素元组的时候，必须在元素后面加逗号 否则的话，创建的是元素对象，而不是元组 单元素 set 集合操作 无序的不重合元素序列 使用set()或者{}创建集合 set不支持序列index操作，没有下标 但是创建一个空集合必须用 set()而不是 { }，因为 { } 是用来创建一个空字典 frozenset() 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素 循环–元素循环 常见用途 成员关系测试 in not in 删除重复元素 差集 | 并集 &amp; 交集 ^ 不同时存在的元素 set无序排序且不重复，是可变的，有add（），remove（）等方法。既然是可变的，所以它不存在哈希值。基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交集), difference(差集)和sysmmetric difference(对称差集)等数学运算.sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, 或其它类序列的操作。frozenset是冻结的集合，它是不可变的，存在哈希值，好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法。 字典 不重复的键值对的无序集合 会覆盖掉的 key:value 模型，键值对之间用逗号隔开 set的升级版 使用{}定义 值可以取任何数据类型，但键必须是不可变的 key不能重复，value可以重复 字典的方法 items() 返回(key,value)列表 keys() 返回keys列表 values() 返回values列表字典的循环 for循环只能使用 元素遍历循环 遍历 key .keys() 遍历 value .values() 遍历 键值对 .items() 成员运算符 in not in 对于list和tuple 是否存在 对于dict，判断键是否存在于字典中 in 操作符 在for循环中，in操作符表示遍历 构造表达式 mylist 变量 = [x 返回值或者元素 for x in range(10) 元素构造表达式 ] 列表构造表达式 字典构造表达式 基本数据类型转换]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2019%2F09%2F23%2FPython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 将代码块**封装到一个def定义的函数名**中 def 关键字 用于定义函数名 之后使用函数名可以多次使用代码块，不需要重写代码块 简化代码编写，代码块反复利用1234def 函数名(参数列表): 函数体#调用函数函数名(实际参数列表) 函数抽象和逐步求精 函数抽象：将函数的使用和函数的实现分开实现 函数的分类 没有参数，没有返回值 参数列表为空 没有 return语句 一般用于打印 字符串 有参数，没有返回值 参数需要传入 没有 return 语句 常用于 打印 变量内容 没有参数，有返回值 没有参数传入 有 return 语句 常用于 返回固定的值或者随机数 需要变量接受返回值 有参数，有返回值 常见的 有参数传入，有返回值 函数的执行顺序 顺序执行 依次执行完成，再执行下一个函数的复合调用过程 瀑布执行 遇到函数调用，就执行函数，当执行到return或者函数体完成时返回到主函数中 继续主函数的执行 函数调用必须等待函数返回之后，才能执行下一步 函数的本质 函数的本质是一个地址 函数名是变量，存储一段代码的地址 所以可以将函数名赋值给另一个变量 但是函数后面接参数的时候，赋值给另一个变量，是将函数的返回数据赋值给变量 直接print(函数名): 可以看到函数名的具体内容 修改地址可以实现不同的行为 函数变量的用途 接口：函数的对外，变量列表，不变 业务需求：是常常变化的， 业务需求发生变化，但是代码内容不变 装饰器模式 函数当作另一个函数的参数 是修改其他函数的功能的函数 封装一个函数，并且用这样或者那样的方式来修改它的行为 用于拓展原来函数功能的一种函数，目的是在不改变原函数名(或类名)的情况下，给函数增加新的功能。 这个函数的特殊之处在于它的返回值也是一个函数，这个函数是内嵌“原“”函数的函数。 None 函数如果没有明确返回值，函数默认返回None 没有return语句，默认返回None 如果print函数或者有变量接受，结果是None 有return语句，但是return 后面没有任何数据，返回None 实际参数 和 形式参数 实参： 函数调用时传入的参数 形参： 函数定义时参数列表中的参数，也就是在函数体中没有赋值直接使用的参数 调用函数时，必须正确传递参数 保持 实参与形参一一对应 默认参数，位置参数 和 关键字参数 默认参数：函数定义时，在参数列表中已经赋值 当函数调用时，没有传入数值，使用默认参数 当函数调用时，传入了数值，使用传入的数值 位置参数：函数调用传入实参，和形参按照位置一一对应 从左向右，依次填充 关键字参数: 函数调用时，使用形参=实参的方式传递数据 也称为：名称参数 顺序可以混乱 位置参数可以和名称参数混用 必须是 先位置参数，再名称参数 print(“zhaolong”,end=” “) 参数副本机制（不可变数据类型） 传递参数时，把实参拷贝给形参，把地址传递给形参 可变数据类型：列表，字典，元组 会改变原来的值 不可变数据类型：数值，字符串 不会改变原来的值 多个返回值 return x,y,z… 函数返回多个参数，以元组的形式返回 需要使用对应的变量接受返回数据 全局变量和局部变量 全局变量：函数外部定义的, 作用范围在程序内部 局部变量：函数内部定义的，作用在函数内部 函数内部的变量会首先查询局部变量，如果没有的话，才会使用同名的全局变量 引用全局变量 global 在函数内部，引用全局变量 使用global关键字申明使用全局变量 在函数内部使用的变量是全局变量 对变量的操作就是对全局变量的操作 函数的嵌套 函数可以嵌套定义 使用内层的函数 必须在外层函数中明确调用内层函数 函数嵌套 同名变量 内层会覆盖外层变量，不同的变量，不同的地址 nonlocal 变量: 不新建新的变量，使用外层的局部变量 nonlocal 用于嵌套函数中 使用外层的局部变量 内层函数使用外层函数的局部变量，使用nonlocal关键字 nonlocal 外层同名变量 不新建本地变量，引用外层局部变量 函数的两种类型 内置函数 builtin_function_method 自定义函数 function 函数的执行顺序 函数执行结束后，之后的代码才可以执行 自上而下，顺序执行 return return 之后的语句不会再被执行 return 表示函数到此结束 lambda 匿名函数 python3的新特性 lambda 关键字 lambda 参数a,b: 返回值 a+b 不需要使用def 12&lt;class 'function'&gt;&lt;function &lt;lambda&gt; at 0x0000023115C09288&gt; 特点 lambda x:print(x):是一个匿名函数 调用的时候需要给函数加（），是一个整体，或则赋值给一个变量 不定长参数 定义函数时，参数未知 使用 *num *num表示一个序列，传入多少数据，接受多个数据 函数调用时，参数之间使用逗号分隔]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python循环-for]]></title>
    <url>%2F2019%2F09%2F23%2FPython%E5%BE%AA%E7%8E%AF-for%2F</url>
    <content type="text"><![CDATA[for循环 Python中的for循环通过一个序列中的每个值来进行迭代 知道循环次数的 计数器控制的循环 不需要使用变量来控制循环 迭代环境，使用的是 可迭代的对象 列表 元组 字典 集合 字符串 for循环处理速度稍微快点 主要是计数器参与运算的，不需要在循环体中再次编写 for 循环的参数是正整数–计数器 range an immutable sequence of numbers 不可变的数字序列，用于For循环中 两种用法 class range(stop) class range(start, stop[, step]) 函数的参数必须是整数 省略step参数，则默认为1.省略start参数，默认为0.如果step为零，则引发ValueError 不包含 stop For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i &gt;= 0 and r[i] &lt; stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i &gt;= 0 and r[i] &gt; stop. 负指数，被解释为从正指数确定的序列末尾开始索引 负方向：表示的是从start开始，每次减去abs(step)的数值,而且 start &gt; stop 本质上，是从start开始到stop-1截至，按照step取值 当step为正数，start&lt;stop,做加法 当step为负数，start&gt;stop，做减法 start != stop i!= 0 else for - else： 恰好即将跳出循环 else 的条件是 最后一个条件 结合for循环，会将最后一个值执行for语句和else语句两次 1234for i in range(10): # for仅仅使用整数 print(i)else: print(i) # for循环与while循环 任何for循环都可以转化为while循环 但是 while循环不一定能转化成for循环 while 循环可以处理实数 while 循环可以处理死循环 for 循环的嵌套 嵌套循环可能会花费很长的时间来允许 用途 显示列表 平面 break continue break 中断循环，直接跳出循环 不会执行else语句 结束多余的循环 continue 结束本次循环，继续下一次循环 忽略continue之后的代码，返回循环头部继续一下次循环 主要起到 筛选作用 break 和 continue 必须搭配 if 进行判断 总结循环的三种方式 while for 死循环+break 控制 break continue else for-else： 即将跳出循环 对最后一个计数器再次处理 while-else: 对 临界值 进行处理 while 风格 设定循环次数，包含了循环终止条件 变量值发生变化 while Ture if break 常见错误：忘记自增或则自减 可以处理浮点数 num - 数值 &lt; 0.000001 for 风格 循环条件 计数器 整数 常使用 range range(100) range(1,100,1) range(100,1,-10) 不包含第二个值 默认步长 1 步长不能为0 -&gt; for不能实现死循环 时间统计 time.time() 返回当前时间，以秒为单位 做减法可以得到时间差 time.sleep(5) 暂停5秒 变量交换 添加临时变量，交换变量 对称赋值 a,b = b,a 先计算=号右边的表达式 交换数据]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python循环-while]]></title>
    <url>%2F2019%2F09%2F23%2FPython%E5%BE%AA%E7%8E%AF-while%2F</url>
    <content type="text"><![CDATA[while循环 条件表达式的结果或本身都被计算成 布尔型 当条件不满足的时候，循环结束 如：None , &quot;&quot;，0 都被转化成 False True 继续循环 1，” “, 1,-1,True,1.234 False 推出循环 None,0,””,False 死循环 条件一直为True，循环会一直执行下去 条件表达式是常量 有限循环 条件在循环过程中会发生改变，结束程序运行 条件使用变量 且在循环过程中 变量的值发生变化 else while-else: 正常退出循环的时候会执行的else语句，不满足条件的时候执行 包含 条件不满足退出 包含 continue语句 包含 刚开始条件就不满足1，直接执行else语句 break跳出循环，不执行else语句 else: 是条件表达式的临界点，处理临界点的 浮点数的科学表达式 正数： 8.16e12 负数： 8.16e-12 浮点数的尾数不确定性导致在循环中不能直接处理，需要通过和0做减法，阈值筛选来使用，否则容易出现你BUG 使用查询来判断浮点数 num - num1&lt; 0.00000001 连续的关系运算符 3 &gt; 2 &gt; 1 —-&gt; 3 &gt;2 and 2 &gt; 1 and 表达式 隐藏的and表达式 if -else 三元表达式 值1 if 条件表达式 else 值2 True 值=值1 False 值= 值2 运算符优先级 循环穷举-编程思想 用于计算 10x+20Y = 10000 确定x的取值范围，做循环，计算 对于的Y值，如果Y值复合条件，就输出 if-表达式的的编程思想 无限划分，遍历每种情况 内存 数据 指令 语音识别 需要使用 win32 包123import win32com.client # 系统客户端的包speaker = win32com.client.Dispatch("SAPI.SPVOICE") # 系统接口speaker.Speak("陈钰琪，1992年7月29日出生于四川省成都市") 输入输出的重定向 使用符号 &gt; 写入文本，覆盖 &gt;&gt; 写入文本，追加 &lt; 从文件中读取 可以连接配合使用 None 空对象 。 属于 NoneType类型 在条件表达式中会自动转化为 False 嵌套逻辑 特别注意： 层级结构 空格或Tab不能混用 不是 if- elif- elif-else 是 if - if - if 条件的等级是并列,且满足其中一个条件的情况下，使用if - elif 语句 条件的顺序是相连的，非顺序，需要添加区域条件 隐含条件 对嵌套的if-if 可以简化 条件的的等级是承接，必须全部满足的的情况下，使用 if-else 语句 运算符的优先级和结合性 运算符的优先级和结合方向决定了运算符的计算顺序 结合性：同意优先级下表达式的计算顺序]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
